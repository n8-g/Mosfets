.CONST G1T 0x00
.CONST G1B 0x08

.CONST G2L 0x10
.CONST G2R 0x18

# Store all 8 neighbors
.CONST MY_N 0x20
.CONST MY_NE 0x23
.CONST MY_E 0x26
.CONST MY_SE 0x29
.CONST MY_S 0x2C
.CONST MY_SW 0x2F
.CONST MY_W 0x32
.CONST MY_NW 0x35

.CONST E_N 0x40
.CONST E_S 0x41
.CONST W_N 0x42
.CONST W_S 0x43

.CONST WIDTH 2
.CONST HEIGHT 2
.CONST PIECES 4
.CONST DEPTH 3
.CONST IMG 0x80

.CONST NBR_N -12
.CONST NBR_NE -9
.CONST NBR_E 3
.CONST NBR_SE 15
.CONST NBR_S 12
.CONST NBR_SW 9
.CONST NBR_W -3
.CONST NBR_NW -15

# For two's complement,  we need to add 001
SET(Y)
CLR(Z)

# First row is a dummy row
LDREG($1, 0)
SET(RAM[$1+IMG])
ADDREG($1, 1)
BNE($1, NBR_S, -2)

LDREG($5, 0) # Row source address
LDREG($2, 0) # Depth counter
:LoadDepth
	CPYREG($1, $2)
	ADDREG($1, NBR_S) # Starting point = IMG + NBR_S + DEPTH
	LDREG($7, 0) # Row counter
	:LoadRow
		SET(RAM[$1+IMG]) # First column is a dummy column
		ADDREG($1, NBR_E)

		LDREG($6, 0) # Col counter
		CPYREG($4, $5) # Piece source address
		:LoadCol
			LOAD(RAM[$1+IMG], $4+0, WIDTH)
			ADDREG($1, NBR_E)
			ADDREG($4, 1)
			ADDREG($6, 1)
			BNE($6, WIDTH, :LoadCol)

		SET(RAM[$1+IMG]) # Last column is a dummy column
		ADDREG($1, NBR_E)
		ADDREG($5, 0x20)
		ADDREG($7, 1)
		BNE($7, HEIGHT, :LoadRow)

	ADDREG($2, 1)
	BNE($2, DEPTH, :LoadDepth)

# Last row is a dummy row
LDREG($2, 0)
SET(RAM[$1+IMG])
ADDREG($1, 1)
ADDREG($2, 1)
BNE($2, NBR_S, -2)

LDREG($7, HEIGHT) # Row counter
LDREG($6, WIDTH) # Column counter
LDREG($5, 0) # Row destination address
LDREG($1, IMG) # Offset to first dummy piece
ADDREG($1, NBR_S) # Offset to first real row

:DoRow
	ADDREG($1, NBR_E) # Skip west dummy
	:DoCol
		CPYREG($4,$5)
		LDREG($2, DEPTH)
		:LoadPlane
			ADDREG($2, -1)
			CPY(NEWS, RAM[$1+NBR_NW])
			BDR(NORTH)
			CPY(NEWS, RAM[$1+NBR_SW])
			BDR(SOUTH) # Need the correct southern border for the shift
			CPY(NEWS, RAM[$1+NBR_W])
			CPY(RAM[W_N], NORTH)
			CPY(RAM[W_S], SOUTH)
			BDR(WEST)
			CPY(NEWS, RAM[$1+NBR_NE])
			BDR(NORTH)
			CPY(NEWS, RAM[$1+NBR_SE])
			BDR(SOUTH) # Need the correct southern border for the shift
			CPY(NEWS, RAM[$1+NBR_E])
			CPY(RAM[E_N], NORTH)
			CPY(RAM[E_S], SOUTH)
			BDR(EAST)
			CPY(NEWS, RAM[$1+NBR_N])
			BDR(NORTH)
			CPY(NEWS, RAM[$1+NBR_S])
			BDR(SOUTH)
			CPY(NEWS, RAM[$1+0])
			CPY(RAM[$2+MY_E], EAST)
			CPY(RAM[$2+MY_W], WEST)
			CPY(RAM[$2+MY_N], NORTH)
			CPY(RAM[$2+MY_S], SOUTH)

			# Shift down
			CPY(NEWS, RAM[E_N])
			BDR(EAST)
			CPY(NEWS, RAM[W_N])
			BDR(WEST)
			CPY(NEWS, RAM[MY_N])
			CPY(RAM[MY_NE], EAST)
			CPY(RAM[MY_NW], WEST)

			# Shift down
			CPY(NEWS, RAM[E_S])
			BDR(EAST)
			CPY(NEWS, RAM[W_S])
			BDR(WEST)
			CPY(NEWS, RAM[MY_S])
			CPY(RAM[MY_SE], EAST)
			CPY(RAM[MY_SW], WEST)

			ADDREG($1, 1) # Next depth
			BNE($2, 0, :LoadPlane) 

		# ======================== G1 ===========================
		# G1T = NE + NW
		LDREG($0, 0)
		CPY(, RAM[MY_NE]) 
		SUM(X, RAM[MY_NW]) # Add east and west together
		CPY(RAM[G1T], X)
		ADDREG($0, 1)
		BNE($0, DEPTH, -4)
		CLR()
		SUM(RAM[G1T], Z)

		# G1T = G1T + N*2
		LDREG($0, 0)
		CPY(, RAM[MY_N])
		SUM(RAM[G1T+1], RAM[G1T+1])
		ADDREG($0, 1)
		BNE($0, DEPTH, -3)
		CLR()
		SUM(RAM[G1T+1], Z)

		# G1B = SE + SW
		LDREG($0, 0)
		CPY(, RAM[MY_SE]) 
		SUM(X, RAM[MY_SW]) # Add east and west together
		CPY(RAM[G1B], X)
		ADDREG($0, 1)
		BNE($0,DEPTH,-4)
		CLR()
		SUM(RAM[G1B], Z)

		# G1B = G1B + S*2
		LDREG($0,0)
		CPY(, RAM[MY_S])
		SUM(RAM[G1B+1], RAM[G1B+1])
		ADDREG($0, 1)
		BNE($0,DEPTH,-4)
		CLR()
		SUM(RAM[G1B+1], Z)

		# G1T = G1T - G1B
		LDREG($0,0)
		SET() # Set accumulator
		SUM(, Y) # Add 1 to generate carry which we'll use for 2's complement
		CPY.INV(, RAM[G1B])
		SUM(RAM[G1T], RAM[G1T])
		ADDREG($0,1)
		BNE($0,DEPTH+2,-3)

		# IF (G1T < 0)
		CLR()
		SUM.INV(FLAG, Z) # Positive sums generate a carry.

		# G1T = -G1T
		LDREG($0,0)
		CPY.INV(, RAM[G1T])
		SUM(RAM[G1T], Y)
		ADDREG($0,1)
		BNE($0,DEPTH+2,-3)
		CLR()
		SUM(, Z) # Discard carry

		# END IF
		SET(FLAG)

		# ======================== G2 ===========================
		# G2L = NW + SW
		LDREG($0, 0)
		CPY(, RAM[MY_NW]) 
		SUM(X, RAM[MY_SW]) # Add east and west together
		CPY(RAM[G2L], X)
		ADDREG($0, 1)
		BNE($0, DEPTH, -4)
		CLR()
		SUM(RAM[G2L], Z)

		# G2L = G2L + W*2
		LDREG($0, 0)
		CPY(, RAM[MY_W])
		SUM(RAM[G2L+1], RAM[G2L+1])
		ADDREG($0, 1)
		BNE($0, DEPTH, -3)
		CLR()
		SUM(RAM[G2L+1], Z)

		# G2R = NE + SE
		LDREG($0, 0)
		CPY(, RAM[MY_NE]) 
		SUM(X, RAM[MY_SE]) # Add east and west together
		CPY(RAM[G2R], X)
		ADDREG($0, 1)
		BNE($0,DEPTH,-4)
		CLR()
		SUM(RAM[G2R], Z)

		# G2R = G2R + E*2
		LDREG($0,0)
		CPY(, RAM[MY_E])
		SUM(RAM[G2R+1], RAM[G2R+1])
		ADDREG($0, 1)
		BNE($0,DEPTH,-4)
		CLR()
		SUM(RAM[G2R+1], Z)

		# G2L = G2L - G2R
		LDREG($0,0)
		SET() # Set accumulator
		SUM(, Y) # Add 1 to generate carry which we'll use for 2's complement
		CPY.INV(, RAM[G2R])
		SUM(RAM[G2L], RAM[G2L])
		ADDREG($0,1)
		BNE($0,DEPTH+2,-3)

		# IF (G2L < 0)
		CLR()
		SUM.INV(FLAG, Z) # Positive sums generate a carry.

		# G2L = -G2L
		LDREG($0,0)
		CPY.INV(, RAM[G2L])
		SUM(RAM[G2L], Y)
		ADDREG($0,1)
		BNE($0,DEPTH+2,-3)
		CLR()
		SUM(, Z) # Discard carry

		# END IF
		SET(FLAG)

		# G1T = G1T + G2L (This is an approximation of G1T = SQRT(G1T^2 + G2L^2))
		LDREG($0,0)
		CPY(, RAM[G2L])
		SUM(RAM[G1T], RAM[G1T])
		ADDREG($0,1)
		BNE($0,DEPTH+2,-3)
		CLR()
		SUM(RAM[G1T], Z)

		# IF (G1T >= 16)
		LDREG($0,DEPTH+1)
		CPY(FLAG, RAM[G1T])
		# G1T = G1T | 15
		LDREG($0,0)
		SET(RAM[G1T])
		ADDREG($0,1)
		BNE($0,DEPTH+1,-2)
		# END IF
		SET(FLAG)

		# Save G1T/2 out
		CPYREG($2,$4)
		LDREG($0,DEPTH)
		ADDREG($0,-1)
		CPY(NEWS, RAM[G1T])
		SAVE($2,WIDTH)
		ADDREG($2,0x40)
		BNE($0,0,-4)
		
		ADDREG($4, 1)
		ADDREG($1, NBR_E) # Next element
		ADDREG($6, -1)
		BNE($6, 0, :DoCol)
	ADDREG($1, NBR_E) # Skip east dummy
	ADDREG($7, -1)
	ADDREG($5, 0x20)
	BNE($7, 0, :DoRow)
