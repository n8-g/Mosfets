.CONST G1T 0x00
.CONST G1B 0x08

.CONST G2L 0x10
.CONST G2R 0x18

# Store all 8 neighbors
.CONST MY_N 0x20
.CONST MY_NE 0x23
.CONST MY_E 0x26
.CONST MY_SE 0x29
.CONST MY_S 0x2C
.CONST MY_SW 0x2F
.CONST MY_W 0x32
.CONST MY_NW 0x35

.CONST E_N 0x40
.CONST E_S 0x41
.CONST W_N 0x42
.CONST W_S 0x43

.CONST COLUMNS 2
.CONST ROWS 2
.CONST DEPTH 3
.CONST IMG 0x80
.CONST ROW_WIDTH 2+COLUMNS # include dummy elements
.CONST ROW_HEIGHT 16*COLUMNS
.CONST PLANE_HEIGHT ROW_HEIGHT*ROWS

.CONST NBR_N DEPTH*(0-ROW_WIDTH)
.CONST NBR_NE DEPTH*(1-ROW_WIDTH)
.CONST NBR_E DEPTH*1
.CONST NBR_SE DEPTH*(1+ROW_WIDTH)
.CONST NBR_S DEPTH*(ROW_WIDTH)
.CONST NBR_SW DEPTH*(ROW_WIDTH-1)
.CONST NBR_W DEPTH*-1
.CONST NBR_NW DEPTH*-ROW_WIDTH

# For two's complement,  we need to add 001
SET(Y)
CLR(Z)

# This is our default offset, and should only be changed when doing summation!
LDREG($0,0)

# First row is a dummy row
LDREG($1, 0)
:Loop
	SET(RAM[$1+IMG])
	ADDREG($1, 1) # Branch delay
	BNE($1, NBR_S - 1, :Loop)

LDREG($5, 0) # Row source address
LDREG($2, DEPTH) # Depth counter
:LoadDepth
	ADDREG($2, -1)
	CPYREG($1, $2)
	ADDREG($1, NBR_S) # Starting point = IMG + NBR_S + depth
	LDREG($7, 0) # Row counter
	:LoadRow
		SET(RAM[$1+IMG]) # First column is a dummy column
		ADDREG($1, NBR_E)

		LDREG($6, 0) # Col counter
		CPYREG($4, $5) # Piece source address
		:LoadCol
			LOAD(RAM[$1+IMG], $4+0, COLUMNS)
			ADDREG($1, NBR_E)
			ADDREG($6, 1)
			ADDREG($4, 1)
			BNE($6, COLUMNS, :LoadCol)

		SET(RAM[$1+IMG]) # Last column is a dummy column
		ADDREG($1, NBR_E)
		ADDREG($7, 1)
		ADDREG($5, ROW_HEIGHT)
		BNE($7, ROWS, :LoadRow)
	BNE($2, 0, :LoadDepth)
	

# Last row is a dummy row
LDREG($2, 0)
:Loop
	SET(RAM[$1+IMG])
	ADDREG($2, 1)
	ADDREG($1, 1)
	BNE($2, NBR_S, :Loop)

LDREG($7, ROWS) # Row counter
LDREG($5, 0) # Row destination address
LDREG($1, IMG+NBR_S) # Offset to first row

:DoRow
	LDREG($6, COLUMNS) # Column counter
	CPYREG($4,$5) # Set destination to start of row
	ADDREG($1, NBR_E) # Skip west dummy
	:DoCol
		LDREG($2, DEPTH)
		:LoadPlane
			ADDREG($2, -1)
			CPY(NEWS, RAM[$1+NBR_NW])
			BDR(NORTH)
			CPY(NEWS, RAM[$1+NBR_SW])
			BDR(SOUTH) # Need the correct southern border for the shift
			CPY(NEWS, RAM[$1+NBR_W])
			CPY(RAM[W_N], NORTH)
			CPY(RAM[W_S], SOUTH)
			BDR(WEST)
			CPY(NEWS, RAM[$1+NBR_NE])
			BDR(NORTH)
			CPY(NEWS, RAM[$1+NBR_SE])
			BDR(SOUTH) # Need the correct southern border for the shift
			CPY(NEWS, RAM[$1+NBR_E])
			CPY(RAM[E_N], NORTH)
			CPY(RAM[E_S], SOUTH)
			BDR(EAST)
			CPY(NEWS, RAM[$1+NBR_N])
			BDR(NORTH)
			CPY(NEWS, RAM[$1+NBR_S])
			BDR(SOUTH)
			CPY(NEWS, RAM[$1+0])
			CPY(RAM[$2+MY_E], EAST)
			CPY(RAM[$2+MY_W], WEST)
			CPY(RAM[$2+MY_N], NORTH)
			CPY(RAM[$2+MY_S], SOUTH)

			# Shift down
			CPY(NEWS, RAM[E_N])
			BDR(EAST)
			CPY(NEWS, RAM[W_N])
			BDR(WEST)
			CPY(NEWS, RAM[MY_N])
			CPY(RAM[MY_NE], EAST)
			CPY(RAM[MY_NW], WEST)

			# Shift down
			CPY(NEWS, RAM[E_S])
			BDR(EAST)
			CPY(NEWS, RAM[W_S])
			BDR(WEST)
			CPY(NEWS, RAM[MY_S])
			CPY(RAM[MY_SE], EAST)
			CPY(RAM[MY_SW], WEST)

			ADDREG($1, 1) # Next depth
			BNE($2, 0, :LoadPlane) 

		# ======================== G1 ===========================
		# G1T = NE + NW
		LDREG($0, 0)
		:Loop
			CPY(, RAM[MY_NE]) 
			SUM(X, RAM[MY_NW]) # Add east and west together
			CPY(RAM[G1T], X)
			ADDREG($0, 1)
			BNE($0, DEPTH, :Loop)
		CLR()
		SUM(RAM[G1T], Z)

		# G1T = G1T + N*2
		LDREG($0, 0)
		:Loop
			CPY(, RAM[MY_N])
			SUM(RAM[G1T+1], RAM[G1T+1])
			ADDREG($0, 1)
			BNE($0, DEPTH, :Loop)
		CLR()
		SUM(RAM[G1T+1], Z)

		# G1B = SE + SW
		LDREG($0, 0)
		:Loop
			CPY(, RAM[MY_SE]) 
			SUM(X, RAM[MY_SW]) # Add east and west together
			CPY(RAM[G1B], X)
			ADDREG($0, 1)
			BNE($0,DEPTH,:Loop)
		CLR()
		SUM(RAM[G1B], Z)

		# G1B = G1B + S*2
		LDREG($0,0)
		:Loop
			CPY(, RAM[MY_S])
			SUM(RAM[G1B+1], RAM[G1B+1])
			ADDREG($0, 1)
			BNE($0,DEPTH,:Loop)
		CLR()
		SUM(RAM[G1B+1], Z)

		# G1T = G1T - G1B
		LDREG($0,0)
		SET() # Set accumulator
		SUM(, Y) # Add 1 to generate carry which we'll use for 2's complement
		:Loop
			CPY.INV(, RAM[G1B])
			SUM(RAM[G1T], RAM[G1T])
			ADDREG($0,1)
			BNE($0,DEPTH+2,:Loop)

		# IF (G1T < 0)
		CLR()
		SUM.INV(FLAG, Z) # Positive sums generate a carry.

		# G1T = -G1T
		LDREG($0,0)
		:Loop
			CPY.INV(, RAM[G1T])
			SUM(RAM[G1T], Y)
			ADDREG($0,1)
			BNE($0,DEPTH+2,:Loop)
		CLR()
		SUM(, Z) # Discard carry

		# END IF
		SET(FLAG)

		# ======================== G2 ===========================
		# G2L = NW + SW
		LDREG($0, 0)
		:Loop
			CPY(, RAM[MY_NW]) 
			SUM(X, RAM[MY_SW]) # Add east and west together
			CPY(RAM[G2L], X)
			ADDREG($0, 1)
			BNE($0, DEPTH, :Loop)
		CLR()
		SUM(RAM[G2L], Z)

		# G2L = G2L + W*2
		LDREG($0, 0)
		:Loop
			CPY(, RAM[MY_W])
			SUM(RAM[G2L+1], RAM[G2L+1])
			ADDREG($0, 1)
			BNE($0, DEPTH, :Loop)
		CLR()
		SUM(RAM[G2L+1], Z)

		# G2R = NE + SE
		LDREG($0, 0)
		:Loop
			CPY(, RAM[MY_NE]) 
			SUM(X, RAM[MY_SE]) # Add east and west together
			CPY(RAM[G2R], X)
			ADDREG($0, 1)
			BNE($0,DEPTH,:Loop)
		CLR()
		SUM(RAM[G2R], Z)

		# G2R = G2R + E*2
		LDREG($0,0)
		:Loop
			CPY(, RAM[MY_E])
			SUM(RAM[G2R+1], RAM[G2R+1])
			ADDREG($0, 1)
			BNE($0,DEPTH,:Loop)
		CLR()
		SUM(RAM[G2R+1], Z)

		# G2L = G2L - G2R
		LDREG($0,0)
		SET() # Set accumulator
		SUM(, Y) # Add 1 to generate carry which we'll use for 2's complement
		:Loop
			CPY.INV(, RAM[G2R])
			SUM(RAM[G2L], RAM[G2L])
			ADDREG($0,1)
			BNE($0,DEPTH+2,:Loop)

		# IF (G2L < 0)
		CLR()
		SUM.INV(FLAG, Z) # Positive sums generate a carry.

		# G2L = -G2L
		LDREG($0,0)
		:Loop
			CPY.INV(, RAM[G2L])
			SUM(RAM[G2L], Y)
			ADDREG($0,1)
			BNE($0,DEPTH+2,:Loop)
		CLR()
		SUM(, Z) # Discard carry

		# END IF
		SET(FLAG)

		# G1T = G1T + G2L (This is an approximation of G1T = SQRT(G1T^2 + G2L^2))
		LDREG($0,0)
		:Loop
			CPY(, RAM[G2L])
			SUM(RAM[G1T], RAM[G1T])
			ADDREG($0,1)
			BNE($0,DEPTH+2,:Loop)
		CLR()
		SUM(RAM[G1T], Z)

		# IF (G1T >= 16)
		LDREG($0,0)
		CPY(FLAG, RAM[G1T+DEPTH+1])
		# G1T = G1T | 15
		:Loop
			SET(RAM[G1T])
			ADDREG($0,1)
			BNE($0,DEPTH+1,:Loop)
		# END IF
		SET(FLAG)

		# Save G1T/2 out
		CPYREG($2,$4)
		LDREG($0,DEPTH)
		:Loop
			ADDREG($0,-1)
			CPY(NEWS, RAM[G1T])
			SAVE($2,COLUMNS)
			ADDREG($2,PLANE_HEIGHT)
			BNE($0,0,:Loop)
		
		ADDREG($4, 1) # Next column
		ADDREG($6, -1)
		ADDREG($1, NBR_E) # Next element
		BNE($6, 0, :DoCol)
	ADDREG($1, NBR_E) # Skip east dummy
	ADDREG($7, -1)
	ADDREG($5, ROW_HEIGHT)
	BNE($7, 0, :DoRow)
