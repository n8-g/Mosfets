.CONST COLUMNS 2
.CONST ROWS 2
.CONST DEPTH 1
.CONST ROW_WIDTH 2+COLUMNS # include dummy elements
.CONST ROW_HEIGHT 16*COLUMNS
.CONST PLANE_HEIGHT ROW_HEIGHT*ROWS
.CONST IMG_SIZE DEPTH*ROW_WIDTH*(ROWS+2)

.CONST NBR_N DEPTH*(0-ROW_WIDTH)
.CONST NBR_NE DEPTH*(1-ROW_WIDTH)
.CONST NBR_E DEPTH*(1)
.CONST NBR_SE DEPTH*(1+ROW_WIDTH)
.CONST NBR_S DEPTH*(ROW_WIDTH)
.CONST NBR_SW DEPTH*(ROW_WIDTH-1)
.CONST NBR_W DEPTH*(-1)
.CONST NBR_NW DEPTH*(-ROW_WIDTH-1)

.CONST IMG 0x80

# Store all 8 neighbors
.VAR[DEPTH] MY_N
.VAR[DEPTH] MY_NE
.VAR[DEPTH] MY_E
.VAR[DEPTH] MY_SE
.VAR[DEPTH] MY_S
.VAR[DEPTH] MY_SW
.VAR[DEPTH] MY_W
.VAR[DEPTH] MY_NW

.VAR[DEPTH] E_N
.VAR[DEPTH] E_S
.VAR[DEPTH] W_N
.VAR[DEPTH] W_S


.VAR[DEPTH+3] G1T
.VAR[DEPTH+3] G1B

.VAR[DEPTH+3] G2L
.VAR[DEPTH+3] G2R


# For two's complement,  we need to add 001
SET(Y)
CLR(Z)

LDREG($0,0)

# Set all 1's in image
LDREG($1, IMG)
:Loop
	SET(RAM[$1])
	ADDREG($1, 1)
	BNE($1, IMG + IMG_SIZE, :Loop)

LDREG($5, 0) # Row source address
LDREG($2, DEPTH) # Depth counter
:LoadDepth
	ADDREG($2, -1)
	CPYREG($1, $2)
	ADDREG($1, IMG+NBR_S) # Starting point = IMG + NBR_S + depth
	LDREG($7, 0) # Row counter
	:LoadRow
		ADDREG($1, NBR_E) # Skip west dummy column

		LDREG($6, 0) # Col counter
		CPYREG($4, $5) # Piece source address
		:LoadCol
			LOAD(RAM[$1+0], $4, COLUMNS)
			ADDREG($1, NBR_E)
			ADDREG($6, 1)
			ADDREG($4, 1)
			BNE($6, COLUMNS, :LoadCol)

		ADDREG($1, NBR_E) # Skip east dummy column
		ADDREG($7, 1)
		ADDREG($5, ROW_HEIGHT)
		BNE($7, ROWS, :LoadRow)
	BNE($2, 0, :LoadDepth)

LDREG($7, ROWS) # Row counter
LDREG($5, 0) # Row destination address
LDREG($1, IMG+NBR_S) # Offset to first row

:DoRow
	LDREG($6, COLUMNS) # Column counter
	CPYREG($4,$5) # Set destination to start of row
	ADDREG($1, NBR_E) # Skip west dummy
	:DoCol
		LDREG($0, DEPTH)
		:LoadPlane
			ADDREG($0, -1) # Decrement depth
			CPY(NEWS, RAM[$1+NBR_NW]) # Load NW neighbor into output register
			BDR(NORTH) # Update border
			CPY(NEWS, RAM[$1+NBR_SW]) # Load SW neighbor into output register
			BDR(SOUTH) # Update border
			CPY(NEWS, RAM[$1+NBR_W]) # Load W neighbor into output register
			BDR(WEST) # Set the west border
			CPY(RAM[W_N], NORTH) # Save its northern and southern neighbors
			CPY(RAM[W_S], SOUTH)
			CPY(NEWS, RAM[$1+NBR_NE])
			BDR(NORTH)
			CPY(NEWS, RAM[$1+NBR_SE])
			BDR(SOUTH)
			CPY(NEWS, RAM[$1+NBR_E])
			BDR(EAST)
			CPY(RAM[E_N], NORTH)
			CPY(RAM[E_S], SOUTH)
			CPY(NEWS, RAM[$1+NBR_N])
			BDR(NORTH)
			CPY(NEWS, RAM[$1+NBR_S])
			BDR(SOUTH)
			CPY(NEWS, RAM[$1+0]) # Load the piece into the output register
			CPY(RAM[MY_E], EAST) # Read immediate neighbors
			CPY(RAM[MY_W], WEST)
			CPY(RAM[MY_N], NORTH)
			CPY(RAM[MY_S], SOUTH)

			# Shift down
			CPY(NEWS, RAM[E_N]) 
			BDR(EAST)
			CPY(NEWS, RAM[W_N])
			BDR(WEST)
			CPY(NEWS, RAM[MY_N])
			CPY(RAM[MY_NE], EAST)
			CPY(RAM[MY_NW], WEST)

			# Shift up
			CPY(NEWS, RAM[E_S])
			BDR(EAST)
			CPY(NEWS, RAM[W_S])
			BDR(WEST)
			CPY(NEWS, RAM[MY_S])
			CPY(RAM[MY_SE], EAST)
			CPY(RAM[MY_SW], WEST)
			
			CPY(NEWS, RAM[$1+0]) # Load the piece into the output register (simply for debugging)

			ADDREG($1, 1) # Next plane
			BNE($0, 0, :LoadPlane) 

		# Sanity check
		LDREG($0, 0)
		:Loop
			CLR(RAM[G1T])
			CLR(RAM[G1B])
			CLR(RAM[G2L])
			CLR(RAM[G2R])
			ADDREG($0,1)
			BNE($0,DEPTH+3, :Loop)
		# ======================== G1 ===========================
		# G1T = NE + NW
		LDREG($0, 0)
		:Loop
			CPY(, RAM[MY_NE]) 
			SUM(X, RAM[MY_NW]) # Add east and west together
			CPY(RAM[G1T], X)
			ADDREG($0, 1)
			BNE($0, DEPTH, :Loop)
		CLR()
		SUM(RAM[G1T], Z)

		# G1T = G1T + N*2
		LDREG($0, 0)
		:Loop
			CPY(, RAM[MY_N])
			SUM(RAM[G1T+1], RAM[G1T+1])
			ADDREG($0, 1)
			BNE($0, DEPTH, :Loop)
		CLR()
		SUM(RAM[G1T+1], Z)

		# G1B = SE + SW
		LDREG($0, 0)
		:Loop
			CPY(, RAM[MY_SE]) 
			SUM(X, RAM[MY_SW]) # Add east and west together
			CPY(RAM[G1B], X)
			ADDREG($0, 1)
			BNE($0,DEPTH,:Loop)
		CLR()
		SUM(RAM[G1B], Z)

		# G1B = G1B + S*2
		LDREG($0,0)
		:Loop
			CPY(, RAM[MY_S])
			SUM(RAM[G1B+1], RAM[G1B+1])
			ADDREG($0, 1)
			BNE($0,DEPTH,:Loop)
		CLR()
		SUM(RAM[G1B+1], Z)

		# G1T = G1T - G1B
		LDREG($0,0)
		SET() # Set accumulator
		SUM(, Y) # Add 1 to generate carry which we'll use for 2's complement
		:Loop
			CPY.INV(, RAM[G1B])
			SUM(RAM[G1T], RAM[G1T])
			ADDREG($0,1)
			BNE($0,DEPTH+2,:Loop)

		# IF (G1T < 0)
		CLR()
		SUM.INV(FLAG, Z) # Positive sums generate a carry.

		# G1T = -G1T
		LDREG($0,0)
		SET() # Set accumulator
		SUM(, Y) # Add 1 to generate carry which we'll use for 2's complement
		:Loop
			CPY.INV(, RAM[G1T])
			SUM(RAM[G1T], Z)
			ADDREG($0,1)
			BNE($0,DEPTH+2,:Loop)
		CLR()
		SUM(, Z) # Discard carry

		# END IF
		SET(FLAG)

		# ======================== G2 ===========================
		# G2L = NW + SW
		LDREG($0, 0)
		:Loop
			CPY(, RAM[MY_NW]) 
			SUM(X, RAM[MY_SW]) # Add east and west together
			CPY(RAM[G2L], X)
			ADDREG($0, 1)
			BNE($0, DEPTH, :Loop)
		CLR()
		SUM(RAM[G2L], Z)

		# G2L = G2L + W*2
		LDREG($0, 0)
		:Loop
			CPY(, RAM[MY_W])
			SUM(RAM[G2L+1], RAM[G2L+1])
			ADDREG($0, 1)
			BNE($0, DEPTH, :Loop)
		CLR()
		SUM(RAM[G2L+1], Z)

		# G2R = NE + SE
		LDREG($0, 0)
		:Loop
			CPY(, RAM[MY_NE]) 
			SUM(X, RAM[MY_SE]) # Add east and west together
			CPY(RAM[G2R], X)
			ADDREG($0, 1)
			BNE($0,DEPTH,:Loop)
		CLR()
		SUM(RAM[G2R], Z)

		# G2R = G2R + E*2
		LDREG($0,0)
		:Loop
			CPY(, RAM[MY_E])
			SUM(RAM[G2R+1], RAM[G2R+1])
			ADDREG($0, 1)
			BNE($0,DEPTH,:Loop)
		CLR()
		SUM(RAM[G2R+1], Z)

		# G2L = G2L - G2R
		LDREG($0,0)
		SET() # Set accumulator
		SUM(, Y) # Add 1 to generate carry which we'll use for 2's complement
		:Loop
			CPY.INV(, RAM[G2R])
			SUM(RAM[G2L], RAM[G2L])
			ADDREG($0,1)
			BNE($0,DEPTH+2,:Loop)

		# IF (G2L < 0)
		CLR()
		SUM.INV(FLAG, Z) # Positive sums generate a carry.

		# G2L = -G2L
		LDREG($0,0)
		SET() # Set accumulator
		SUM(, Y) # Add 1 to generate carry which we'll use for 2's complement
		:Loop
			CPY.INV(, RAM[G2L])
			SUM(RAM[G2L], Z)
			ADDREG($0,1)
			BNE($0,DEPTH+2,:Loop)
		CLR()
		SUM(, Z) # Discard carry

		# END IF
		SET(FLAG)
		
		# ============================ Combining them ============================
		
		# G1T = G1T + G2L (This is an approximation of G1T = SQRT(G1T^2 + G2L^2))
		LDREG($0,0)
		:Loop
			CPY(, RAM[G2L])
			SUM(RAM[G1T], RAM[G1T])
			ADDREG($0,1)
			BNE($0,DEPTH+2,:Loop)
		CLR()
		SUM(RAM[G1T], Z)

		# IF (G1T >= 16)
		LDREG($0,0)
		CPY(FLAG, RAM[G1T+DEPTH+1])
		# G1T = G1T | 15
		:Loop
			SET(RAM[G1T])
			ADDREG($0,1)
			BNE($0,DEPTH+1,:Loop)
		# END IF
		SET(FLAG)

		# Save G1T/2 out
		CPYREG($3,$4)
		LDREG($0,DEPTH)
		:Loop
			CPY(NEWS, RAM[G1T])
			SAVE($3,COLUMNS)
			ADDREG($3,PLANE_HEIGHT)
			ADDREG($0,-1)
			BNE($0,0,:Loop)
		
		ADDREG($4, 1) # Next column
		ADDREG($6, -1)
		BNE($6, 0, :DoCol)
	ADDREG($1, NBR_E) # Skip east dummy
	ADDREG($7, -1)
	ADDREG($5, ROW_HEIGHT)
	BNE($7, 0, :DoRow)
