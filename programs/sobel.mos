LOAD(255,0x0)
LOAD(255,0x1)
LOAD(255,0x2)
LOAD(255,0x3)
LOAD(255,0x4)
LOAD(255,0x5)
LOAD(255,0x6)
LOAD(255,0x7)
LOAD(255,0x8)
LOAD(255,0x9)
LOAD(255,0xA)
LOAD(255,0xB)
LOAD(255,0xC)
LOAD(255,0xD)
LOAD(255,0xE)
LOAD(255,0xF)
LOAD(254,0x10)
LOAD(254,0x11)
LOAD(254,0x12)
LOAD(254,0x13)
LOAD(254,0x14)
LOAD(254,0x15)
LOAD(254,0x16)
LOAD(254,0x17)
LOAD(254,0x18)
LOAD(254,0x19)
LOAD(254,0x1A)
LOAD(254,0x1B)
LOAD(254,0x1C)
LOAD(254,0x1D)
LOAD(254,0x1E)
LOAD(254,0x1F)
LOAD(253,0x20)
LOAD(253,0x21)
LOAD(253,0x22)
LOAD(253,0x23)
LOAD(253,0x24)
LOAD(253,0x25)
LOAD(253,0x26)
LOAD(253,0x27)
LOAD(253,0x28)
LOAD(253,0x29)
LOAD(253,0x2A)
LOAD(253,0x2B)
LOAD(253,0x2C)
LOAD(253,0x2D)
LOAD(253,0x2E)
LOAD(253,0x2F)

# For two's complement, we need to add 001
SET(Y)
CLR(Z)

# ======================== G1 ===========================
# Top corners
CPY(NEWS,RAM[253])
CPY(NEWS,NORTH) # Shift down
CPY(,EAST) 
SUM(RAM[0x0],WEST) # Add east and west together
CPY(NEWS,RAM[254])
CPY(NEWS,NORTH)
CPY(,EAST)
SUM(RAM[0x1],WEST)
CPY(NEWS,RAM[255])
CPY(NEWS,NORTH)
CPY(,EAST)
SUM(RAM[0x2],WEST)
RDCAR(RAM[0x3])

# Add Top (shifted up 1)
CPY(NEWS,RAM[253])
CPY(,NORTH)
SUM(RAM[0x1],RAM[0x1])
CPY(NEWS,RAM[254])
CPY(,NORTH)
SUM(RAM[0x2],RAM[0x2])
CPY(NEWS,RAM[255])
CPY(,NORTH)
SUM(RAM[0x3],RAM[0x3])
CLR()
SUM(RAM[0x4],Z)

# Bottom corners
CPY(NEWS,RAM[253])
CPY(NEWS,SOUTH) # Shift down
CPY(,EAST) 
SUM(RAM[0x5],WEST) # Add east and west together
CPY(NEWS,RAM[254])
CPY(NEWS,SOUTH)
CPY(,EAST)
SUM(RAM[0x6],WEST)
CPY(NEWS,RAM[255])
CPY(NEWS,SOUTH)
CPY(,EAST)
SUM(RAM[0x7],WEST)
CLR()
SUM(RAM[0x8],Z)

# Add Bottom (shifted up 1)
CPY(NEWS,RAM[253])
CPY(,SOUTH)
SUM(RAM[0x6],RAM[0x6])
CPY(NEWS,RAM[254])
CPY(,SOUTH)
SUM(RAM[0x7],RAM[0x7])
CPY(NEWS,RAM[255])
CPY(,SOUTH)
SUM(RAM[0x8],RAM[0x8])
CLR()
SUM(RAM[0x9],Z)

# Calculate top - bottom
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[0x5])
SUM(RAM[0x0],RAM[0x0])
CPY.INV(,RAM[0x6])
SUM(RAM[0x1],RAM[0x1])
CPY.INV(,RAM[0x7])
SUM(RAM[0x2],RAM[0x2])
CPY.INV(,RAM[0x8])
SUM(RAM[0x3],RAM[0x3])
CPY.INV(,RAM[0x9])
SUM(RAM[0x4],RAM[0x4])

# IF (Negative)
RDCAR.INV(FLAG) # Positive sums generate a carry.

# Absolute value - Negate if we're negative
CPY.INV(,RAM[0x0])
SUM(RAM[0x0],Y)
CPY.INV(,RAM[0x1])
SUM(RAM[0x1],Z)
CPY.INV(,RAM[0x2])
SUM(RAM[0x2],Z)
CPY.INV(,RAM[0x3])
SUM(RAM[0x3],Z)
CPY.INV(,RAM[0x4])
SUM(RAM[0x4],Z)
CLR()
SUM(,Z) # Discard carry

SET(FLAG) 
# END IF (Negative)

# ======================== G2 ===========================
# West corners
CPY(NEWS,RAM[253])
CPY(NEWS,WEST) 
CPY(,NORTH) 
SUM(RAM[0x10],SOUTH) 
CPY(NEWS,RAM[254])
CPY(NEWS,WEST)
CPY(,NORTH)
SUM(RAM[0x11],SOUTH)
CPY(NEWS,RAM[255])
CPY(NEWS,WEST)
CPY(,NORTH)
SUM(RAM[0x12],SOUTH)
CLR()
SUM(RAM[0x13],Z)

# Add West (shifted up 1)
CPY(NEWS,RAM[253])
CPY(,WEST)
SUM(RAM[0x11],RAM[0x11])
CPY(NEWS,RAM[254])
CPY(,WEST)
SUM(RAM[0x12],RAM[0x12])
CPY(NEWS,RAM[255])
CPY(,WEST)
SUM(RAM[0x13],RAM[0x13])
CLR()
SUM(RAM[0x14],Z)

# East corners
CPY(NEWS,RAM[253])
CPY(NEWS,EAST)
CPY(,NORTH) 
SUM(RAM[0x15],SOUTH)
CPY(NEWS,RAM[254])
CPY(NEWS,EAST)
CPY(,NORTH)
SUM(RAM[0x16],SOUTH)
CPY(NEWS,RAM[255])
CPY(NEWS,EAST)
CPY(,NORTH)
SUM(RAM[0x17],SOUTH)
CLR()
SUM(RAM[0x18],Z)

# Add Bottom (shifted up 1)
CPY(NEWS,RAM[253])
CPY(,EAST)
SUM(RAM[0x16],RAM[0x16])
CPY(NEWS,RAM[254])
CPY(,EAST)
SUM(RAM[0x17],RAM[0x17])
CPY(NEWS,RAM[255])
CPY(,EAST)
SUM(RAM[0x18],RAM[0x18])
CLR()
SUM(RAM[0x19],Z)

# Calculate east - west
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[0x15])
SUM(RAM[0x10],RAM[0x10])
CPY.INV(,RAM[0x16])
SUM(RAM[0x11],RAM[0x11])
CPY.INV(,RAM[0x17])
SUM(RAM[0x12],RAM[0x12])
CPY.INV(,RAM[0x18])
SUM(RAM[0x13],RAM[0x13])
CPY.INV(,RAM[0x19])
SUM(RAM[0x14],RAM[0x14])

# IF (Negative)
RDCAR.INV(FLAG) # Positive sums generate a carry.

# Absolute value - Negate if we're negative
CPY.INV(,RAM[0x10])
SUM(RAM[0x10],Y)
CPY.INV(,RAM[0x11])
SUM(RAM[0x11],Z)
CPY.INV(,RAM[0x12])
SUM(RAM[0x12],Z)
CPY.INV(,RAM[0x13])
SUM(RAM[0x13],Z)
CPY.INV(,RAM[0x14])
SUM(RAM[0x14],Z)
CLR()
SUM(,Z) # Discard carry

SET(FLAG) 
# END IF (Negative)

# Sum the two results together (apparently an approximation)
CPY(,RAM[0x10])
SUM(RAM[0x0],RAM[0x0])
CPY(,RAM[0x11])
SUM(RAM[0x1],RAM[0x1])
CPY(,RAM[0x12])
SUM(RAM[0x2],RAM[0x2])
CPY(,RAM[0x13])
SUM(RAM[0x3],RAM[0x3])
CPY(,RAM[0x14])
SUM(RAM[0x4],RAM[0x4])
CLR()
SUM(,Z) # If we oversaturated, make it white
OR(,RAM[0x4])
OR(FLAG,RAM[0x3])
SET(RAM[0x0])
SET(RAM[0x1])
SET(RAM[0x2])
SET(FLAG)

CPY(NEWS,RAM[0x2])
SAVE(0x0)
SAVE(0x1)
SAVE(0x2)
SAVE(0x3)
SAVE(0x4)
SAVE(0x5)
SAVE(0x6)
SAVE(0x7)
SAVE(0x8)
SAVE(0x9)
SAVE(0xA)
SAVE(0xB)
SAVE(0xC)
SAVE(0xD)
SAVE(0xE)
SAVE(0xF)

CPY(NEWS,RAM[0x1])
SAVE(0x10)
SAVE(0x11)
SAVE(0x12)
SAVE(0x13)
SAVE(0x14)
SAVE(0x15)
SAVE(0x16)
SAVE(0x17)
SAVE(0x18)
SAVE(0x19)
SAVE(0x1A)
SAVE(0x1B)
SAVE(0x1C)
SAVE(0x1D)
SAVE(0x1E)
SAVE(0x1F)

CPY(NEWS,RAM[0x0])
SAVE(0x20)
SAVE(0x21)
SAVE(0x22)
SAVE(0x23)
SAVE(0x24)
SAVE(0x25)
SAVE(0x26)
SAVE(0x27)
SAVE(0x28)
SAVE(0x29)
SAVE(0x2A)
SAVE(0x2B)
SAVE(0x2C)
SAVE(0x2D)
SAVE(0x2E)
SAVE(0x2F)

# Discard remaining bits
