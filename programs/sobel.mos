.CONST NW0 0xFF
.CONST NW1 0xFE
.CONST NW2 0xFD
.CONST NE0 0xFC
.CONST NE1 0xFB
.CONST NE2 0xFA
.CONST SW0 0xF9
.CONST SW1 0xF8
.CONST SW2 0xF7
.CONST SE0 0xF6
.CONST SE1 0xF5
.CONST SE2 0xF4

.CONST IMG_NW0 0x00
.CONST IMG_NE0 0x01
.CONST IMG_SW0 0x20
.CONST IMG_SE0 0x21
.CONST IMG_NW1 0x40
.CONST IMG_NE1 0x41
.CONST IMG_SW1 0x60
.CONST IMG_SE1 0x61
.CONST IMG_NW2 0x80
.CONST IMG_NE2 0x81
.CONST IMG_SW2 0xA0
.CONST IMG_SE2 0xA1

.CONST G1T0 0x00
.CONST G1T1 0x01
.CONST G1T2 0x02
.CONST G1T3 0x03
.CONST G1T4 0x04
.CONST G1T5 0x0A

.CONST G1B0 0x05
.CONST G1B1 0x06
.CONST G1B2 0x07
.CONST G1B3 0x08
.CONST G1B4 0x09

.CONST G2L0 0x10
.CONST G2L1 0x11
.CONST G2L2 0x12
.CONST G2L3 0x13
.CONST G2L4 0x14

.CONST G2R0 0x15
.CONST G2R1 0x16
.CONST G2R2 0x17
.CONST G2R3 0x18
.CONST G2R4 0x19

# Store all 8 neighbors
.CONST MY_N0 0x20
.CONST MY_N1 0x21
.CONST MY_N2 0x22
.CONST MY_NE0 0x23
.CONST MY_NE1 0x24
.CONST MY_NE2 0x25
.CONST MY_E0 0x26
.CONST MY_E1 0x27
.CONST MY_E2 0x28
.CONST MY_SE0 0x29
.CONST MY_SE1 0x2A
.CONST MY_SE2 0x2B
.CONST MY_S0 0x2C
.CONST MY_S1 0x2D
.CONST MY_S2 0x2E
.CONST MY_SW0 0x2F
.CONST MY_SW1 0x30
.CONST MY_SW2 0x31
.CONST MY_W0 0x32
.CONST MY_W1 0x33
.CONST MY_W2 0x34
.CONST MY_NW0 0x35
.CONST MY_NW1 0x36
.CONST MY_NW2 0x37

.CONST NW_N0 0x40
.CONST NW_N1 0x41
.CONST NW_N2 0x42
.CONST NE_N0 0x43
.CONST NE_N1 0x44
.CONST NE_N2 0x45
.CONST SW_N0 0x46
.CONST SW_N1 0x47
.CONST SW_N2 0x48
.CONST SE_N0 0x49
.CONST SE_N1 0x4A
.CONST SE_N2 0x4B

.CONST NW_S0 0x50
.CONST NW_S1 0x51
.CONST NW_S2 0x52
.CONST NE_S0 0x53
.CONST NE_S1 0x54
.CONST NE_S2 0x55
.CONST SW_S0 0x56
.CONST SW_S1 0x57
.CONST SW_S2 0x58
.CONST SE_S0 0x59
.CONST SE_S1 0x5A
.CONST SE_S2 0x5B

# For two's complement, we need to add 001
SET(Y)
CLR(Z)

# Load entire image
LOAD(RAM[NW0],IMG_NW0,2)
LOAD(RAM[NE0],IMG_NE0,2)
LOAD(RAM[SW0],IMG_SW0,2)
LOAD(RAM[SE0],IMG_SE0,2)
LOAD(RAM[NW1],IMG_NW1,2)
LOAD(RAM[NE1],IMG_NE1,2)
LOAD(RAM[SW1],IMG_SW1,2)
LOAD(RAM[SE1],IMG_SE1,2)
LOAD(RAM[NW2],IMG_NW2,2)
LOAD(RAM[NE2],IMG_NE2,2)
LOAD(RAM[SW2],IMG_SW2,2)
LOAD(RAM[SE2],IMG_SE2,2)

########################## NW ##########################
# Read ALL neigbors into ram. This will make calculations easier later

SET(NEWS)
BDR(NORTH)
BDR(WEST)
# ----------------- PLANE 0 -----------------
CPY(NEWS,RAM[SE0])
BDR(SOUTH) # Need the correct southern border for the shift
CPY(NEWS,RAM[NE0])
CPY(RAM[NE_N0],NORTH)
CPY(RAM[NE_S0],SOUTH)
BDR(EAST)
CPY(NEWS,RAM[NW0])
BDR(NORTH) # Need the correct northern border for the shift
SET(NEWS)
BDR(SOUTH) # Need the correct southern border for the shift
CPY(NEWS,RAM[SW0])
CPY(RAM[SW_N0],NORTH)
CPY(RAM[SW_S0],SOUTH)
BDR(SOUTH)
SET(NEWS)
BDR(NORTH) # Restore northern border
CPY(NEWS,RAM[NW0])
CPY(RAM[MY_E0],EAST)
CPY(RAM[MY_W0],WEST)
CPY(RAM[MY_N0],NORTH)
CPY(RAM[MY_S0],SOUTH)

# Shift down
CPY(NEWS,RAM[NE_N0])
BDR(EAST)
CPY(NEWS,RAM[SW_N0])
BDR(SOUTH)
CPY(NEWS,RAM[MY_N0])
CPY(RAM[MY_NE0],EAST)
CPY(RAM[MY_NW0],WEST)

# Shift up
CPY(NEWS,RAM[NE_S0])
BDR(EAST)
CPY(NEWS,RAM[SW_S0])
BDR(SOUTH)
CPY(NEWS,RAM[MY_S0])
CPY(RAM[MY_SE0],EAST)
CPY(RAM[MY_SW0],WEST)
# ----------------- PLANE 1 -----------------
CPY(NEWS,RAM[SE1])
BDR(SOUTH) # Need the correct southern border for the shift
CPY(NEWS,RAM[NE1])
CPY(RAM[NE_N1],NORTH)
CPY(RAM[NE_S1],SOUTH)
BDR(EAST)
CPY(NEWS,RAM[NW1])
BDR(NORTH) # Need the correct northern border for the shift
SET(NEWS)
BDR(SOUTH) # Need the correct southern border for the shift
CPY(NEWS,RAM[SW1])
CPY(RAM[SW_N1],NORTH)
CPY(RAM[SW_S1],SOUTH)
BDR(SOUTH)
SET(NEWS)
BDR(NORTH) # Restore northern border
CPY(NEWS,RAM[NW1])
CPY(RAM[MY_E1],EAST)
CPY(RAM[MY_W1],WEST)
CPY(RAM[MY_N1],NORTH)
CPY(RAM[MY_S1],SOUTH)

# Shift down
CPY(NEWS,RAM[NE_N1])
BDR(EAST)
CPY(NEWS,RAM[SW_N1])
BDR(SOUTH)
CPY(NEWS,RAM[MY_N1])
CPY(RAM[MY_NE1],EAST)
CPY(RAM[MY_NW1],WEST)

# Shift up
CPY(NEWS,RAM[NE_S1])
BDR(EAST)
CPY(NEWS,RAM[SW_S1])
BDR(SOUTH)
CPY(NEWS,RAM[MY_S1])
CPY(RAM[MY_SE1],EAST)
CPY(RAM[MY_SW1],WEST)
# ----------------- PLANE 2 -----------------
CPY(NEWS,RAM[SE2])
BDR(SOUTH) # Need the correct southern border for the shift
CPY(NEWS,RAM[NE2])
CPY(RAM[NE_N2],NORTH)
CPY(RAM[NE_S2],SOUTH)
BDR(EAST)
CPY(NEWS,RAM[NW2])
BDR(NORTH) # Need the correct northern border for the shift
SET(NEWS)
BDR(SOUTH) # Need the correct southern border for the shift
CPY(NEWS,RAM[SW2])
CPY(RAM[SW_N2],NORTH)
CPY(RAM[SW_S2],SOUTH)
BDR(SOUTH)
SET(NEWS)
BDR(NORTH) # Restore northern border
CPY(NEWS,RAM[NW2])
CPY(RAM[MY_E2],EAST)
CPY(RAM[MY_W2],WEST)
CPY(RAM[MY_N2],NORTH)
CPY(RAM[MY_S2],SOUTH)

# Shift down
CPY(NEWS,RAM[NE_N2])
BDR(EAST)
CPY(NEWS,RAM[SW_N2])
BDR(SOUTH)
CPY(NEWS,RAM[MY_N2])
CPY(RAM[MY_NE2],EAST)
CPY(RAM[MY_NW2],WEST)

# Shift up
CPY(NEWS,RAM[NE_S2])
BDR(EAST)
CPY(NEWS,RAM[SW_S2])
BDR(SOUTH)
CPY(NEWS,RAM[MY_S2])
CPY(RAM[MY_SE2],EAST)
CPY(RAM[MY_SW2],WEST)

# ======================== G1 ===========================
# G1T = NE + NW
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_NW0]) # Add east and west together
CPY(RAM[G1T0],X)
CPY(,RAM[MY_NE1]) 
SUM(X,RAM[MY_NW1]) # Add east and west together
CPY(RAM[G1T1],X)
CPY(,RAM[MY_NE2]) 
SUM(X,RAM[MY_NW2]) # Add east and west together
CPY(RAM[G1T2],X)
CLR()
SUM(RAM[G1T3],Z)

# G1T = G1T + N*2
CPY(,RAM[MY_N0])
SUM(RAM[G1T1],RAM[G1T1])
CPY(,RAM[MY_N1])
SUM(RAM[G1T2],RAM[G1T2])
CPY(,RAM[MY_N2])
SUM(RAM[G1T3],RAM[G1T3])
CLR()
SUM(RAM[G1T4],Z)

# G1B = SE + SW
CPY(,RAM[MY_SE0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G1B0],X)
CPY(,RAM[MY_SE1]) 
SUM(X,RAM[MY_SW1]) # Add east and west together
CPY(RAM[G1B1],X)
CPY(,RAM[MY_SE2]) 
SUM(X,RAM[MY_SW2]) # Add east and west together
CPY(RAM[G1B2],X)
CLR()
SUM(RAM[G1B3],Z)

# G1B = G1B + S*2
CPY(,RAM[MY_S0])
SUM(RAM[G1B1],RAM[G1B1])
CPY(,RAM[MY_S1])
SUM(RAM[G1B2],RAM[G1B2])
CPY(,RAM[MY_S2])
SUM(RAM[G1B3],RAM[G1B3])
CLR()
SUM(RAM[G1B4],Z)

# G1T = G1T - G1B
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G1B0])
SUM(RAM[G1T0],RAM[G1T0])
CPY.INV(,RAM[G1B1])
SUM(RAM[G1T1],RAM[G1T1])
CPY.INV(,RAM[G1B2])
SUM(RAM[G1T2],RAM[G1T2])
CPY.INV(,RAM[G1B3])
SUM(RAM[G1T3],RAM[G1T3])
CPY.INV(,RAM[G1B4])
SUM(RAM[G1T4],RAM[G1T4])

# IF (G1T < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G1T = -G1T
CPY.INV(,RAM[G1T0])
SUM(RAM[G1T0],Y)
CPY.INV(,RAM[G1T1])
SUM(RAM[G1T1],Z)
CPY.INV(,RAM[G1T2])
SUM(RAM[G1T2],Z)
CPY.INV(,RAM[G1T3])
SUM(RAM[G1T3],Z)
CPY.INV(,RAM[G1T4])
SUM(RAM[G1T4],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# ======================== G2 ===========================
# G2L = NW + SW
CPY(,RAM[MY_NW0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G2L0],X)
CPY(,RAM[MY_NW1]) 
SUM(X,RAM[MY_SW1]) # Add east and west together
CPY(RAM[G2L1],X)
CPY(,RAM[MY_NW2]) 
SUM(X,RAM[MY_SW2]) # Add east and west together
CPY(RAM[G2L2],X)
CLR()
SUM(RAM[G2L3],Z)

# G2L = G2L + W*2
CPY(,RAM[MY_W0])
SUM(RAM[G2L1],RAM[G2L1])
CPY(,RAM[MY_W1])
SUM(RAM[G2L2],RAM[G2L2])
CPY(,RAM[MY_W2])
SUM(RAM[G2L3],RAM[G2L3])
CLR()
SUM(RAM[G2L4],Z)

# G2R = NE + SE
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_SE0]) # Add east and west together
CPY(RAM[G2R0],X)
CPY(,RAM[MY_NE1]) 
SUM(X,RAM[MY_SE1]) # Add east and west together
CPY(RAM[G2R1],X)
CPY(,RAM[MY_NE2]) 
SUM(X,RAM[MY_SE2]) # Add east and west together
CPY(RAM[G2R2],X)
CLR()
SUM(RAM[G2R3],Z)

# G2R = G2R + E*2
CPY(,RAM[MY_E0])
SUM(RAM[G2R1],RAM[G2R1])
CPY(,RAM[MY_E1])
SUM(RAM[G2R2],RAM[G2R2])
CPY(,RAM[MY_E2])
SUM(RAM[G2R3],RAM[G2R3])
CLR()
SUM(RAM[G2R4],Z)

# G2L = G2L - G2R
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G2R0])
SUM(RAM[G2L0],RAM[G2L0])
CPY.INV(,RAM[G2R1])
SUM(RAM[G2L1],RAM[G2L1])
CPY.INV(,RAM[G2R2])
SUM(RAM[G2L2],RAM[G2L2])
CPY.INV(,RAM[G2R3])
SUM(RAM[G2L3],RAM[G2L3])
CPY.INV(,RAM[G2R4])
SUM(RAM[G2L4],RAM[G2L4])

# IF (G2L < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G2L = -G2L
CPY.INV(,RAM[G2L0])
SUM(RAM[G2L0],Y)
CPY.INV(,RAM[G2L1])
SUM(RAM[G2L1],Z)
CPY.INV(,RAM[G2L2])
SUM(RAM[G2L2],Z)
CPY.INV(,RAM[G2L3])
SUM(RAM[G2L3],Z)
CPY.INV(,RAM[G2L4])
SUM(RAM[G2L4],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# G1T = G1T + G2L (This is an approximation of G1T = SQRT(G1T^2 + G2L^2))
CPY(,RAM[G2L0])
SUM(RAM[G1T0],RAM[G1T0])
CPY(,RAM[G2L1])
SUM(RAM[G1T1],RAM[G1T1])
CPY(,RAM[G2L2])
SUM(RAM[G1T2],RAM[G1T2])
CPY(,RAM[G2L3])
SUM(RAM[G1T3],RAM[G1T3])
CPY(,RAM[G2L4])
SUM(RAM[G1T4],RAM[G1T4])
CLR()
SUM(RAM[G1T5],Z)

# IF (G1T >= 16)
CPY(FLAG,RAM[G1T4])
OR(,RAM[G1T5])
# G1T = G1T | 15
SET(RAM[G1T0])
SET(RAM[G1T1])
SET(RAM[G1T2])
SET(RAM[G1T3])
# END IF
SET(FLAG)

# Save G1T/2 out
CPY(NEWS,RAM[G1T3])
SAVE(IMG_NW2,2)
CPY(NEWS,RAM[G1T2])
SAVE(IMG_NW1,2)
CPY(NEWS,RAM[G1T1])
SAVE(IMG_NW0,2)

########################## NE ##########################
# Read ALL neigbors into ram. This will make calculations easier later

SET(NEWS)
BDR(NORTH)
BDR(EAST)
# ----------------- PLANE 0 -----------------
CPY(NEWS,RAM[SW0])
BDR(SOUTH) # Need the correct southern border for the shift
CPY(NEWS,RAM[NW0])
CPY(RAM[NW_N0],NORTH)
CPY(RAM[NW_S0],SOUTH)
BDR(WEST)
CPY(NEWS,RAM[NE0])
BDR(NORTH) # Need the correct northern border for the shift
SET(NEWS)
BDR(SOUTH) # Need the correct southern border
CPY(NEWS,RAM[SE0])
CPY(RAM[SE_N0],NORTH)
CPY(RAM[SE_S0],SOUTH)
BDR(SOUTH)
SET(NEWS)
BDR(NORTH) # Restore northern border
CPY(NEWS,RAM[NE0])
CPY(RAM[MY_E0],EAST)
CPY(RAM[MY_W0],WEST)
CPY(RAM[MY_N0],NORTH)
CPY(RAM[MY_S0],SOUTH)

# Shift down
CPY(NEWS,RAM[NW_N0])
BDR(WEST)
CPY(NEWS,RAM[SE_N0])
BDR(SOUTH)
CPY(NEWS,RAM[MY_N0])
CPY(RAM[MY_NE0],EAST)
CPY(RAM[MY_NW0],WEST)

# Shift up
CPY(NEWS,RAM[NW_S0])
BDR(WEST)
CPY(NEWS,RAM[SE_S0])
BDR(SOUTH)
CPY(NEWS,RAM[MY_S0])
CPY(RAM[MY_SE0],EAST)
CPY(RAM[MY_SW0],WEST)
# ----------------- PLANE 1 -----------------
CPY(NEWS,RAM[SW1])
BDR(SOUTH) # Need the correct southern border for the shift
CPY(NEWS,RAM[NW1])
CPY(RAM[NW_N1],NORTH)
CPY(RAM[NW_S1],SOUTH)
BDR(WEST)
CPY(NEWS,RAM[NE1])
BDR(NORTH) # Need the correct northern border for the shift
SET(NEWS)
BDR(SOUTH) # Need the correct southern border
CPY(NEWS,RAM[SE1])
CPY(RAM[SE_N1],NORTH)
CPY(RAM[SE_S1],SOUTH)
BDR(SOUTH)
SET(NEWS)
BDR(NORTH) # Restore northern border
CPY(NEWS,RAM[NE1])
CPY(RAM[MY_E1],EAST)
CPY(RAM[MY_W1],WEST)
CPY(RAM[MY_N1],NORTH)
CPY(RAM[MY_S1],SOUTH)

# Shift down
CPY(NEWS,RAM[NW_N1])
BDR(WEST)
CPY(NEWS,RAM[SE_N1])
BDR(SOUTH)
CPY(NEWS,RAM[MY_N1])
CPY(RAM[MY_NE1],EAST)
CPY(RAM[MY_NW1],WEST)

# Shift up
CPY(NEWS,RAM[NW_S1])
BDR(WEST)
CPY(NEWS,RAM[SE_S1])
BDR(SOUTH)
CPY(NEWS,RAM[MY_S1])
CPY(RAM[MY_SE1],EAST)
CPY(RAM[MY_SW1],WEST)
# ----------------- PLANE 2 -----------------
CPY(NEWS,RAM[SW2])
BDR(SOUTH) # Need the correct southern border for the shift
CPY(NEWS,RAM[NW2])
CPY(RAM[NW_N2],NORTH)
CPY(RAM[NW_S2],SOUTH)
BDR(WEST)
CPY(NEWS,RAM[NE2])
BDR(NORTH) # Need the correct northern border for the shift
SET(NEWS)
BDR(SOUTH) # Need the correct southern border
CPY(NEWS,RAM[SE2])
CPY(RAM[SE_N2],NORTH)
CPY(RAM[SE_S2],SOUTH)
BDR(SOUTH)
SET(NEWS)
BDR(NORTH) # Restore northern border
CPY(NEWS,RAM[NE2])
CPY(RAM[MY_E2],EAST)
CPY(RAM[MY_W2],WEST)
CPY(RAM[MY_N2],NORTH)
CPY(RAM[MY_S2],SOUTH)

# Shift down
CPY(NEWS,RAM[NW_N2])
BDR(WEST)
CPY(NEWS,RAM[SE_N2])
BDR(SOUTH)
CPY(NEWS,RAM[MY_N2])
CPY(RAM[MY_NE2],EAST)
CPY(RAM[MY_NW2],WEST)

# Shift up
CPY(NEWS,RAM[NW_S2])
BDR(WEST)
CPY(NEWS,RAM[SE_S2])
BDR(SOUTH)
CPY(NEWS,RAM[MY_S2])
CPY(RAM[MY_SE2],EAST)
CPY(RAM[MY_SW2],WEST)

# ======================== G1 ===========================
# G1T = NE + NW
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_NW0]) # Add east and west together
CPY(RAM[G1T0],X)
CPY(,RAM[MY_NE1]) 
SUM(X,RAM[MY_NW1]) # Add east and west together
CPY(RAM[G1T1],X)
CPY(,RAM[MY_NE2]) 
SUM(X,RAM[MY_NW2]) # Add east and west together
CPY(RAM[G1T2],X)
CLR()
SUM(RAM[G1T3],Z)

# G1T = G1T + N*2
CPY(,RAM[MY_N0])
SUM(RAM[G1T1],RAM[G1T1])
CPY(,RAM[MY_N1])
SUM(RAM[G1T2],RAM[G1T2])
CPY(,RAM[MY_N2])
SUM(RAM[G1T3],RAM[G1T3])
CLR()
SUM(RAM[G1T4],Z)

# G1B = SE + SW
CPY(,RAM[MY_SE0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G1B0],X)
CPY(,RAM[MY_SE1]) 
SUM(X,RAM[MY_SW1]) # Add east and west together
CPY(RAM[G1B1],X)
CPY(,RAM[MY_SE2]) 
SUM(X,RAM[MY_SW2]) # Add east and west together
CPY(RAM[G1B2],X)
CLR()
SUM(RAM[G1B3],Z)

# G1B = G1B + S*2
CPY(,RAM[MY_S0])
SUM(RAM[G1B1],RAM[G1B1])
CPY(,RAM[MY_S1])
SUM(RAM[G1B2],RAM[G1B2])
CPY(,RAM[MY_S2])
SUM(RAM[G1B3],RAM[G1B3])
CLR()
SUM(RAM[G1B4],Z)

# G1T = G1T - G1B
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G1B0])
SUM(RAM[G1T0],RAM[G1T0])
CPY.INV(,RAM[G1B1])
SUM(RAM[G1T1],RAM[G1T1])
CPY.INV(,RAM[G1B2])
SUM(RAM[G1T2],RAM[G1T2])
CPY.INV(,RAM[G1B3])
SUM(RAM[G1T3],RAM[G1T3])
CPY.INV(,RAM[G1B4])
SUM(RAM[G1T4],RAM[G1T4])

# IF (G1T < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G1T = -G1T
CPY.INV(,RAM[G1T0])
SUM(RAM[G1T0],Y)
CPY.INV(,RAM[G1T1])
SUM(RAM[G1T1],Z)
CPY.INV(,RAM[G1T2])
SUM(RAM[G1T2],Z)
CPY.INV(,RAM[G1T3])
SUM(RAM[G1T3],Z)
CPY.INV(,RAM[G1T4])
SUM(RAM[G1T4],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# ======================== G2 ===========================
# G2L = NW + SW
CPY(,RAM[MY_NW0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G2L0],X)
CPY(,RAM[MY_NW1]) 
SUM(X,RAM[MY_SW1]) # Add east and west together
CPY(RAM[G2L1],X)
CPY(,RAM[MY_NW2]) 
SUM(X,RAM[MY_SW2]) # Add east and west together
CPY(RAM[G2L2],X)
CLR()
SUM(RAM[G2L3],Z)

# G2L = G2L + W*2
CPY(,RAM[MY_W0])
SUM(RAM[G2L1],RAM[G2L1])
CPY(,RAM[MY_W1])
SUM(RAM[G2L2],RAM[G2L2])
CPY(,RAM[MY_W2])
SUM(RAM[G2L3],RAM[G2L3])
CLR()
SUM(RAM[G2L4],Z)

# G2R = NE + SE
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_SE0]) # Add east and west together
CPY(RAM[G2R0],X)
CPY(,RAM[MY_NE1]) 
SUM(X,RAM[MY_SE1]) # Add east and west together
CPY(RAM[G2R1],X)
CPY(,RAM[MY_NE2]) 
SUM(X,RAM[MY_SE2]) # Add east and west together
CPY(RAM[G2R2],X)
CLR()
SUM(RAM[G2R3],Z)

# G2R = G2R + E*2
CPY(,RAM[MY_E0])
SUM(RAM[G2R1],RAM[G2R1])
CPY(,RAM[MY_E1])
SUM(RAM[G2R2],RAM[G2R2])
CPY(,RAM[MY_E2])
SUM(RAM[G2R3],RAM[G2R3])
CLR()
SUM(RAM[G2R4],Z)

# G2L = G2L - G2R
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G2R0])
SUM(RAM[G2L0],RAM[G2L0])
CPY.INV(,RAM[G2R1])
SUM(RAM[G2L1],RAM[G2L1])
CPY.INV(,RAM[G2R2])
SUM(RAM[G2L2],RAM[G2L2])
CPY.INV(,RAM[G2R3])
SUM(RAM[G2L3],RAM[G2L3])
CPY.INV(,RAM[G2R4])
SUM(RAM[G2L4],RAM[G2L4])

# IF (G2L < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G2L = -G2L
CPY.INV(,RAM[G2L0])
SUM(RAM[G2L0],Y)
CPY.INV(,RAM[G2L1])
SUM(RAM[G2L1],Z)
CPY.INV(,RAM[G2L2])
SUM(RAM[G2L2],Z)
CPY.INV(,RAM[G2L3])
SUM(RAM[G2L3],Z)
CPY.INV(,RAM[G2L4])
SUM(RAM[G2L4],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# G1T = G1T + G2L (This is an approximation of G1T = SQRT(G1T^2 + G2L^2))
CPY(,RAM[G2L0])
SUM(RAM[G1T0],RAM[G1T0])
CPY(,RAM[G2L1])
SUM(RAM[G1T1],RAM[G1T1])
CPY(,RAM[G2L2])
SUM(RAM[G1T2],RAM[G1T2])
CPY(,RAM[G2L3])
SUM(RAM[G1T3],RAM[G1T3])
CPY(,RAM[G2L4])
SUM(RAM[G1T4],RAM[G1T4])
CLR()
SUM(RAM[G1T5],Z)

# IF (G1T >= 16)
CPY(,RAM[G1T5])
OR(FLAG,RAM[G1T4])
# G1T = G1T | 15
SET(RAM[G1T0])
SET(RAM[G1T1])
SET(RAM[G1T2])
SET(RAM[G1T3])
# END IF
SET(FLAG)

# Save G1T/2 out
CPY(NEWS,RAM[G1T3])
SAVE(IMG_NE2,2)
CPY(NEWS,RAM[G1T2])
SAVE(IMG_NE1,2)
CPY(NEWS,RAM[G1T1])
SAVE(IMG_NE0,2)

########################## SW ##########################
# Read ALL neigbors into ram. This will make calculations easier later

SET(NEWS)
BDR(SOUTH)
BDR(WEST)
# ----------------- PLANE 0 -----------------
CPY(NEWS,RAM[SE0])
BDR(EAST)
CPY(NEWS,RAM[NW0])
BDR(NORTH)
CPY(NEWS,RAM[SW0])
CPY(RAM[MY_E0],EAST)
CPY(RAM[MY_W0],WEST)
CPY(RAM[MY_N0],NORTH)
CPY(RAM[MY_S0],SOUTH)

# Shift down
CPY(NEWS,RAM[SE_N0])
BDR(EAST)
CPY(NEWS,RAM[NW_N0])
BDR(NORTH)
CPY(NEWS,RAM[MY_N0])
CPY(RAM[MY_NE0],EAST)
CPY(RAM[MY_NW0],WEST)

# Shift up
CPY(NEWS,RAM[SE_S0])
BDR(EAST)
CPY(NEWS,RAM[NW_S0])
BDR(NORTH)
CPY(NEWS,RAM[MY_S0])
CPY(RAM[MY_SE0],EAST)
CPY(RAM[MY_SW0],WEST)
# ----------------- PLANE 1 -----------------
CPY(NEWS,RAM[SE1])
BDR(EAST)
CPY(NEWS,RAM[NW1])
BDR(NORTH)
CPY(NEWS,RAM[SW1])
CPY(RAM[MY_E1],EAST)
CPY(RAM[MY_W1],WEST)
CPY(RAM[MY_N1],NORTH)
CPY(RAM[MY_S1],SOUTH)

# Shift down
CPY(NEWS,RAM[SE_N1])
BDR(EAST)
CPY(NEWS,RAM[NW_N1])
BDR(NORTH)
CPY(NEWS,RAM[MY_N1])
CPY(RAM[MY_NE1],EAST)
CPY(RAM[MY_NW1],WEST)

# Shift up
CPY(NEWS,RAM[SE_S1])
BDR(EAST)
CPY(NEWS,RAM[NW_S1])
BDR(NORTH)
CPY(NEWS,RAM[MY_S1])
CPY(RAM[MY_SE1],EAST)
CPY(RAM[MY_SW1],WEST)
# ----------------- PLANE 2 -----------------
CPY(NEWS,RAM[SE2])
BDR(EAST)
CPY(NEWS,RAM[NW2])
BDR(NORTH)
CPY(NEWS,RAM[SW2])
CPY(RAM[MY_E2],EAST)
CPY(RAM[MY_W2],WEST)
CPY(RAM[MY_N2],NORTH)
CPY(RAM[MY_S2],SOUTH)

# Shift down
CPY(NEWS,RAM[SE_N2])
BDR(EAST)
CPY(NEWS,RAM[NW_N2])
BDR(NORTH)
CPY(NEWS,RAM[MY_N2])
CPY(RAM[MY_NE2],EAST)
CPY(RAM[MY_NW2],WEST)

# Shift up
CPY(NEWS,RAM[SE_S2])
BDR(EAST)
CPY(NEWS,RAM[NW_S2])
BDR(NORTH)
CPY(NEWS,RAM[MY_S2])
CPY(RAM[MY_SE2],EAST)
CPY(RAM[MY_SW2],WEST)

# ======================== G1 ===========================
# G1T = NE + NW
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_NW0]) # Add east and west together
CPY(RAM[G1T0],X)
CPY(,RAM[MY_NE1]) 
SUM(X,RAM[MY_NW1]) # Add east and west together
CPY(RAM[G1T1],X)
CPY(,RAM[MY_NE2]) 
SUM(X,RAM[MY_NW2]) # Add east and west together
CPY(RAM[G1T2],X)
CLR()
SUM(RAM[G1T3],Z)

# G1T = G1T + N*2
CPY(,RAM[MY_N0])
SUM(RAM[G1T1],RAM[G1T1])
CPY(,RAM[MY_N1])
SUM(RAM[G1T2],RAM[G1T2])
CPY(,RAM[MY_N2])
SUM(RAM[G1T3],RAM[G1T3])
CLR()
SUM(RAM[G1T4],Z)

# G1B = SE + SW
CPY(,RAM[MY_SE0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G1B0],X)
CPY(,RAM[MY_SE1]) 
SUM(X,RAM[MY_SW1]) # Add east and west together
CPY(RAM[G1B1],X)
CPY(,RAM[MY_SE2]) 
SUM(X,RAM[MY_SW2]) # Add east and west together
CPY(RAM[G1B2],X)
CLR()
SUM(RAM[G1B3],Z)

# G1B = G1B + S*2
CPY(,RAM[MY_S0])
SUM(RAM[G1B1],RAM[G1B1])
CPY(,RAM[MY_S1])
SUM(RAM[G1B2],RAM[G1B2])
CPY(,RAM[MY_S2])
SUM(RAM[G1B3],RAM[G1B3])
CLR()
SUM(RAM[G1B4],Z)

# G1T = G1T - G1B
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G1B0])
SUM(RAM[G1T0],RAM[G1T0])
CPY.INV(,RAM[G1B1])
SUM(RAM[G1T1],RAM[G1T1])
CPY.INV(,RAM[G1B2])
SUM(RAM[G1T2],RAM[G1T2])
CPY.INV(,RAM[G1B3])
SUM(RAM[G1T3],RAM[G1T3])
CPY.INV(,RAM[G1B4])
SUM(RAM[G1T4],RAM[G1T4])

# IF (G1T < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G1T = -G1T
CPY.INV(,RAM[G1T0])
SUM(RAM[G1T0],Y)
CPY.INV(,RAM[G1T1])
SUM(RAM[G1T1],Z)
CPY.INV(,RAM[G1T2])
SUM(RAM[G1T2],Z)
CPY.INV(,RAM[G1T3])
SUM(RAM[G1T3],Z)
CPY.INV(,RAM[G1T4])
SUM(RAM[G1T4],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# ======================== G2 ===========================
# G2L = NW + SW
CPY(,RAM[MY_NW0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G2L0],X)
CPY(,RAM[MY_NW1]) 
SUM(X,RAM[MY_SW1]) # Add east and west together
CPY(RAM[G2L1],X)
CPY(,RAM[MY_NW2]) 
SUM(X,RAM[MY_SW2]) # Add east and west together
CPY(RAM[G2L2],X)
CLR()
SUM(RAM[G2L3],Z)

# G2L = G2L + W*2
CPY(,RAM[MY_W0])
SUM(RAM[G2L1],RAM[G2L1])
CPY(,RAM[MY_W1])
SUM(RAM[G2L2],RAM[G2L2])
CPY(,RAM[MY_W2])
SUM(RAM[G2L3],RAM[G2L3])
CLR()
SUM(RAM[G2L4],Z)

# G2R = NE + SE
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_SE0]) # Add east and west together
CPY(RAM[G2R0],X)
CPY(,RAM[MY_NE1]) 
SUM(X,RAM[MY_SE1]) # Add east and west together
CPY(RAM[G2R1],X)
CPY(,RAM[MY_NE2]) 
SUM(X,RAM[MY_SE2]) # Add east and west together
CPY(RAM[G2R2],X)
CLR()
SUM(RAM[G2R3],Z)

# G2R = G2R + E*2
CPY(,RAM[MY_E0])
SUM(RAM[G2R1],RAM[G2R1])
CPY(,RAM[MY_E1])
SUM(RAM[G2R2],RAM[G2R2])
CPY(,RAM[MY_E2])
SUM(RAM[G2R3],RAM[G2R3])
CLR()
SUM(RAM[G2R4],Z)

# G2L = G2L - G2R
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G2R0])
SUM(RAM[G2L0],RAM[G2L0])
CPY.INV(,RAM[G2R1])
SUM(RAM[G2L1],RAM[G2L1])
CPY.INV(,RAM[G2R2])
SUM(RAM[G2L2],RAM[G2L2])
CPY.INV(,RAM[G2R3])
SUM(RAM[G2L3],RAM[G2L3])
CPY.INV(,RAM[G2R4])
SUM(RAM[G2L4],RAM[G2L4])

# IF (G2L < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G2L = -G2L
CPY.INV(,RAM[G2L0])
SUM(RAM[G2L0],Y)
CPY.INV(,RAM[G2L1])
SUM(RAM[G2L1],Z)
CPY.INV(,RAM[G2L2])
SUM(RAM[G2L2],Z)
CPY.INV(,RAM[G2L3])
SUM(RAM[G2L3],Z)
CPY.INV(,RAM[G2L4])
SUM(RAM[G2L4],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# G1T = G1T + G2L (This is an approximation of G1T = SQRT(G1T^2 + G2L^2))
CPY(,RAM[G2L0])
SUM(RAM[G1T0],RAM[G1T0])
CPY(,RAM[G2L1])
SUM(RAM[G1T1],RAM[G1T1])
CPY(,RAM[G2L2])
SUM(RAM[G1T2],RAM[G1T2])
CPY(,RAM[G2L3])
SUM(RAM[G1T3],RAM[G1T3])
CPY(,RAM[G2L4])
SUM(RAM[G1T4],RAM[G1T4])
CLR()
SUM(RAM[G1T5],Z)

# IF (G1T >= 16)
CPY(,RAM[G1T5])
OR(FLAG,RAM[G1T4])
# G1T = G1T | 15
SET(RAM[G1T0])
SET(RAM[G1T1])
SET(RAM[G1T2])
SET(RAM[G1T3])
# END IF
SET(FLAG)

# Save G1T/2 out
CPY(NEWS,RAM[G1T3])
SAVE(IMG_SW2,2)
CPY(NEWS,RAM[G1T2])
SAVE(IMG_SW1,2)
CPY(NEWS,RAM[G1T1])
SAVE(IMG_SW0,2)

########################## SE ##########################
# Read ALL neigbors into ram. This will make calculations easier later

SET(NEWS)
BDR(SOUTH)
BDR(EAST)
# ----------------- PLANE 0 -----------------
CPY(NEWS,RAM[SW0])
BDR(WEST)
CPY(NEWS,RAM[NE0])
BDR(NORTH)
CPY(NEWS,RAM[SE0])
CPY(RAM[MY_E0],EAST)
CPY(RAM[MY_W0],WEST)
CPY(RAM[MY_N0],NORTH)
CPY(RAM[MY_S0],SOUTH)

# Shift down
CPY(NEWS,RAM[SW_N0])
BDR(WEST)
CPY(NEWS,RAM[NE_N0])
BDR(NORTH)
CPY(NEWS,RAM[MY_N0])
CPY(RAM[MY_NE0],EAST)
CPY(RAM[MY_NW0],WEST)

# Shift up
CPY(NEWS,RAM[SW_S0])
BDR(WEST)
CPY(NEWS,RAM[NE_S0])
BDR(NORTH)
CPY(NEWS,RAM[MY_S0])
CPY(RAM[MY_SE0],EAST)
CPY(RAM[MY_SW0],WEST)
# ----------------- PLANE 1 -----------------
CPY(NEWS,RAM[SW1])
BDR(WEST)
CPY(NEWS,RAM[NE1])
BDR(NORTH)
CPY(NEWS,RAM[SE1])
CPY(RAM[MY_E1],EAST)
CPY(RAM[MY_W1],WEST)
CPY(RAM[MY_N1],NORTH)
CPY(RAM[MY_S1],SOUTH)

# Shift down
CPY(NEWS,RAM[SW_N1])
BDR(WEST)
CPY(NEWS,RAM[NE_N1])
BDR(NORTH)
CPY(NEWS,RAM[MY_N1])
CPY(RAM[MY_NE1],EAST)
CPY(RAM[MY_NW1],WEST)

# Shift up
CPY(NEWS,RAM[SW_S1])
BDR(WEST)
CPY(NEWS,RAM[NE_S1])
BDR(NORTH)
CPY(NEWS,RAM[MY_S1])
CPY(RAM[MY_SE1],EAST)
CPY(RAM[MY_SW1],WEST)
# ----------------- PLANE 2 -----------------
CPY(NEWS,RAM[SW2])
BDR(WEST)
CPY(NEWS,RAM[NE2])
BDR(NORTH)
CPY(NEWS,RAM[SE2])
CPY(RAM[MY_E2],EAST)
CPY(RAM[MY_W2],WEST)
CPY(RAM[MY_N2],NORTH)
CPY(RAM[MY_S2],SOUTH)

# Shift down
CPY(NEWS,RAM[SW_N2])
BDR(WEST)
CPY(NEWS,RAM[NE_N2])
BDR(NORTH)
CPY(NEWS,RAM[MY_N2])
CPY(RAM[MY_NE2],EAST)
CPY(RAM[MY_NW2],WEST)

# Shift up
CPY(NEWS,RAM[SW_S2])
BDR(WEST)
CPY(NEWS,RAM[NE_S2])
BDR(NORTH)
CPY(NEWS,RAM[MY_S2])
CPY(RAM[MY_SE2],EAST)
CPY(RAM[MY_SW2],WEST)

# ======================== G1 ===========================
# G1T = NE + NW
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_NW0]) # Add east and west together
CPY(RAM[G1T0],X)
CPY(,RAM[MY_NE1]) 
SUM(X,RAM[MY_NW1]) # Add east and west together
CPY(RAM[G1T1],X)
CPY(,RAM[MY_NE2]) 
SUM(X,RAM[MY_NW2]) # Add east and west together
CPY(RAM[G1T2],X)
CLR()
SUM(RAM[G1T3],Z)

# G1T = G1T + N*2
CPY(,RAM[MY_N0])
SUM(RAM[G1T1],RAM[G1T1])
CPY(,RAM[MY_N1])
SUM(RAM[G1T2],RAM[G1T2])
CPY(,RAM[MY_N2])
SUM(RAM[G1T3],RAM[G1T3])
CLR()
SUM(RAM[G1T4],Z)

# G1B = SE + SW
CPY(,RAM[MY_SE0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G1B0],X)
CPY(,RAM[MY_SE1]) 
SUM(X,RAM[MY_SW1]) # Add east and west together
CPY(RAM[G1B1],X)
CPY(,RAM[MY_SE2]) 
SUM(X,RAM[MY_SW2]) # Add east and west together
CPY(RAM[G1B2],X)
CLR()
SUM(RAM[G1B3],Z)

# G1B = G1B + S*2
CPY(,RAM[MY_S0])
SUM(RAM[G1B1],RAM[G1B1])
CPY(,RAM[MY_S1])
SUM(RAM[G1B2],RAM[G1B2])
CPY(,RAM[MY_S2])
SUM(RAM[G1B3],RAM[G1B3])
CLR()
SUM(RAM[G1B4],Z)

# G1T = G1T - G1B
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G1B0])
SUM(RAM[G1T0],RAM[G1T0])
CPY.INV(,RAM[G1B1])
SUM(RAM[G1T1],RAM[G1T1])
CPY.INV(,RAM[G1B2])
SUM(RAM[G1T2],RAM[G1T2])
CPY.INV(,RAM[G1B3])
SUM(RAM[G1T3],RAM[G1T3])
CPY.INV(,RAM[G1B4])
SUM(RAM[G1T4],RAM[G1T4])

# IF (G1T < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G1T = -G1T
CPY.INV(,RAM[G1T0])
SUM(RAM[G1T0],Y)
CPY.INV(,RAM[G1T1])
SUM(RAM[G1T1],Z)
CPY.INV(,RAM[G1T2])
SUM(RAM[G1T2],Z)
CPY.INV(,RAM[G1T3])
SUM(RAM[G1T3],Z)
CPY.INV(,RAM[G1T4])
SUM(RAM[G1T4],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# ======================== G2 ===========================
# G2L = NW + SW
CPY(,RAM[MY_NW0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G2L0],X)
CPY(,RAM[MY_NW1]) 
SUM(X,RAM[MY_SW1]) # Add east and west together
CPY(RAM[G2L1],X)
CPY(,RAM[MY_NW2]) 
SUM(X,RAM[MY_SW2]) # Add east and west together
CPY(RAM[G2L2],X)
CLR()
SUM(RAM[G2L3],Z)

# G2L = G2L + W*2
CPY(,RAM[MY_W0])
SUM(RAM[G2L1],RAM[G2L1])
CPY(,RAM[MY_W1])
SUM(RAM[G2L2],RAM[G2L2])
CPY(,RAM[MY_W2])
SUM(RAM[G2L3],RAM[G2L3])
CLR()
SUM(RAM[G2L4],Z)

# G2R = NE + SE
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_SE0]) # Add east and west together
CPY(RAM[G2R0],X)
CPY(,RAM[MY_NE1]) 
SUM(X,RAM[MY_SE1]) # Add east and west together
CPY(RAM[G2R1],X)
CPY(,RAM[MY_NE2]) 
SUM(X,RAM[MY_SE2]) # Add east and west together
CPY(RAM[G2R2],X)
CLR()
SUM(RAM[G2R3],Z)

# G2R = G2R + E*2
CPY(,RAM[MY_E0])
SUM(RAM[G2R1],RAM[G2R1])
CPY(,RAM[MY_E1])
SUM(RAM[G2R2],RAM[G2R2])
CPY(,RAM[MY_E2])
SUM(RAM[G2R3],RAM[G2R3])
CLR()
SUM(RAM[G2R4],Z)

# G2L = G2L - G2R
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G2R0])
SUM(RAM[G2L0],RAM[G2L0])
CPY.INV(,RAM[G2R1])
SUM(RAM[G2L1],RAM[G2L1])
CPY.INV(,RAM[G2R2])
SUM(RAM[G2L2],RAM[G2L2])
CPY.INV(,RAM[G2R3])
SUM(RAM[G2L3],RAM[G2L3])
CPY.INV(,RAM[G2R4])
SUM(RAM[G2L4],RAM[G2L4])

# IF (G2L < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G2L = -G2L
CPY.INV(,RAM[G2L0])
SUM(RAM[G2L0],Y)
CPY.INV(,RAM[G2L1])
SUM(RAM[G2L1],Z)
CPY.INV(,RAM[G2L2])
SUM(RAM[G2L2],Z)
CPY.INV(,RAM[G2L3])
SUM(RAM[G2L3],Z)
CPY.INV(,RAM[G2L4])
SUM(RAM[G2L4],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# G1T = G1T + G2L (This is an approximation of G1T = SQRT(G1T^2 + G2L^2))
CPY(,RAM[G2L0])
SUM(RAM[G1T0],RAM[G1T0])
CPY(,RAM[G2L1])
SUM(RAM[G1T1],RAM[G1T1])
CPY(,RAM[G2L2])
SUM(RAM[G1T2],RAM[G1T2])
CPY(,RAM[G2L3])
SUM(RAM[G1T3],RAM[G1T3])
CPY(,RAM[G2L4])
SUM(RAM[G1T4],RAM[G1T4])
CLR()
SUM(RAM[G1T5],Z)

# IF (G1T >= 8)
CPY(,RAM[G1T5])
OR(FLAG,RAM[G1T4])
# G1T = G1T | 15
SET(RAM[G1T0])
SET(RAM[G1T1])
SET(RAM[G1T2])
SET(RAM[G1T3])
# END IF
SET(FLAG)

# Save G1T out
CPY(NEWS,RAM[G1T3])
SAVE(IMG_SE2,2)
CPY(NEWS,RAM[G1T2])
SAVE(IMG_SE1,2)
CPY(NEWS,RAM[G1T1])
SAVE(IMG_SE0,2)
