.ADDR NW0 0xFF
.ADDR NE0 0xFC
.ADDR SW0 0xF9
.ADDR SE0 0xF6

.ADDR IMG_NW0 0x00
.ADDR IMG_NE0 0x01
.ADDR IMG_SW0 0x20
.ADDR IMG_SE0 0x21

.ADDR G1T0 0x00
.ADDR G1T1 0x01
.ADDR G1T2 0x02

.ADDR G1B0 0x05
.ADDR G1B1 0x06
.ADDR G1B2 0x07

.ADDR G2L0 0x10
.ADDR G2L1 0x11
.ADDR G2L2 0x12

.ADDR G2R0 0x15
.ADDR G2R1 0x16
.ADDR G2R2 0x17

# Store all 8 neighbors
.ADDR MY_N0 0x20
.ADDR MY_NE0 0x23
.ADDR MY_E0 0x26
.ADDR MY_SE0 0x29
.ADDR MY_S0 0x2C
.ADDR MY_SW0 0x2F
.ADDR MY_W0 0x32
.ADDR MY_NW0 0x35

# For two's complement, we need to add 001
SET(Y)
CLR(Z)

# Load entire image
LOAD(NW0,IMG_NW0)
LOAD(NE0,IMG_NE0)
LOAD(SW0,IMG_SW0)
LOAD(SE0,IMG_SE0)

########################## NW ##########################
# Read ALL neigbors into ram. This will make calculations easier later

# ----------------- PLANE 0 -----------------
SET(NEWS)
BDR(NORTH)
BDR(WEST)
CPY(NEWS,RAM[NE0])
BDR(EAST)
CPY(NEWS,RAM[SW0])
BDR(SOUTH)
CPY(NEWS,RAM[NW0])
CPY(RAM[MY_E0],EAST)
CPY(RAM[MY_W0],WEST)
CPY(NEWS RAM[MY_N0],NORTH) # Shift south
CPY(RAM[MY_NE0],EAST)
CPY(RAM[MY_NW0],WEST)
CPY(NEWS,RAM[NW0]) # Restore
CPY(NEWS RAM[MY_S0],SOUTH) # Shift north
CPY(RAM[MY_SE0],EAST)
CPY(RAM[MY_SW0],WEST)

# ======================== G1 ===========================
# G1T = NE + NW
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_NW0]) # Add east and west together
CPY(RAM[G1T0],X)
CLR()
SUM(RAM[G1T1],Z)

# G1T = G1T + N*2
CPY(,RAM[MY_N0])
SUM(RAM[G1T1],RAM[G1T1])
CLR()
SUM(RAM[G1T2],Z)

# G1B = SE + SW
CPY(,RAM[MY_SE0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G1B0],X)
CLR()
SUM(RAM[G1B1],Z)

# G1B = G1B + S*2
CPY(,RAM[MY_S0])
SUM(RAM[G1B1],RAM[G1B1])
CLR()
SUM(RAM[G1B2],Z)

# G1T = G1T - G1B
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G1B0])
SUM(RAM[G1T0],RAM[G1T0])
CPY.INV(,RAM[G1B1])
SUM(RAM[G1T1],RAM[G1T1])
CPY.INV(,RAM[G1B2])
SUM(RAM[G1T2],RAM[G1T2])

# IF (G1T < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G1T = -G1T
CPY.INV(,RAM[G1T0])
SUM(RAM[G1T0],Y)
CPY.INV(,RAM[G1T1])
SUM(RAM[G1T1],Z)
CPY.INV(,RAM[G1T2])
SUM(RAM[G1T2],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# ======================== G2 ===========================
# G2L = NW + SW
CPY(,RAM[MY_NW0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G2L0],X)
CLR()
SUM(RAM[G2L1],Z)

# G2L = G2L + W*2
CPY(,RAM[MY_W0])
SUM(RAM[G2L1],RAM[G2L1])
CLR()
SUM(RAM[G2L2],Z)

# G2R = NE + SE
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_SE0]) # Add east and west together
CPY(RAM[G2R0],X)
CLR()
SUM(RAM[G2R1],Z)

# G2R = G2R + E*2
CPY(,RAM[MY_W0])
SUM(RAM[G2R1],RAM[G2R1])
CLR()
SUM(RAM[G2R2],Z)

# G2L = G2L - G2R
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G2R0])
SUM(RAM[G2L0],RAM[G2L0])
CPY.INV(,RAM[G2R1])
SUM(RAM[G2L1],RAM[G2L1])
CPY.INV(,RAM[G2R2])
SUM(RAM[G2L2],RAM[G2L2])

# IF (G2L < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G1T = -G1T
CPY.INV(,RAM[G1T0])
SUM(RAM[G1T0],Y)
CPY.INV(,RAM[G1T1])
SUM(RAM[G1T1],Z)
CPY.INV(,RAM[G1T2])
SUM(RAM[G1T2],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# G1T = G1T + G2L (This is an approximation of G1T = SQRT(G1T^2 + G2L^2))
CPY(,RAM[G2L0])
SUM(RAM[G1T0],RAM[G1T0])
CPY(,RAM[G2L1])
SUM(RAM[G1T1],RAM[G1T1])
CPY(,RAM[G2L2])
SUM(RAM[G1T2],RAM[G1T2])
CLR()
SUM(,Z)

# IF (G1T >= 4)
CPY(FLAG,RAM[G1T2])
# G1T = G1T | 3
SET(RAM[G1T0])
SET(RAM[G1T1])
# END IF
SET(FLAG)

# Save G1T/2 out
CPY(NEWS,RAM[G1T1])
SAVE(IMG_NW0)

########################## NE ##########################
# Read ALL neigbors into ram. This will make calculations easier later

# ----------------- PLANE 0 -----------------
SET(NEWS)
BDR(NORTH)
BDR(EAST)
CPY(NEWS,RAM[NW0])
BDR(WEST)
CPY(NEWS,RAM[SE0])
BDR(SOUTH)
CPY(NEWS,RAM[NE0])
CPY(RAM[MY_E0],EAST)
CPY(RAM[MY_W0],WEST)
CPY(NEWS RAM[MY_N0],NORTH) # Shift south
CPY(RAM[MY_NE0],EAST)
CPY(RAM[MY_NW0],WEST)
CPY(NEWS,RAM[NE0]) # Restore
CPY(NEWS RAM[MY_S0],SOUTH) # Shift north
CPY(RAM[MY_SE0],EAST)
CPY(RAM[MY_SW0],WEST)

# ======================== G1 ===========================
# G1T = NE + NW
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_NW0]) # Add east and west together
CPY(RAM[G1T0],X)
CLR()
SUM(RAM[G1T1],Z)

# G1T = G1T + N*2
CPY(,RAM[MY_N0])
SUM(RAM[G1T1],RAM[G1T1])
CLR()
SUM(RAM[G1T2],Z)

# G1B = SE + SW
CPY(,RAM[MY_SE0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G1B0],X)
CLR()
SUM(RAM[G1B1],Z)

# G1B = G1B + S*2
CPY(,RAM[MY_S0])
SUM(RAM[G1B1],RAM[G1B1])
CLR()
SUM(RAM[G1B2],Z)

# G1T = G1T - G1B
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G1B0])
SUM(RAM[G1T0],RAM[G1T0])
CPY.INV(,RAM[G1B1])
SUM(RAM[G1T1],RAM[G1T1])
CPY.INV(,RAM[G1B2])
SUM(RAM[G1T2],RAM[G1T2])

# IF (G1T < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G1T = -G1T
CPY.INV(,RAM[G1T0])
SUM(RAM[G1T0],Y)
CPY.INV(,RAM[G1T1])
SUM(RAM[G1T1],Z)
CPY.INV(,RAM[G1T2])
SUM(RAM[G1T2],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# ======================== G2 ===========================
# G2L = NW + SW
CPY(,RAM[MY_NW0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G2L0],X)
CLR()
SUM(RAM[G2L1],Z)

# G2L = G2L + W*2
CPY(,RAM[MY_W0])
SUM(RAM[G2L1],RAM[G2L1])
CLR()
SUM(RAM[G2L2],Z)

# G2R = NE + SE
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_SE0]) # Add east and west together
CPY(RAM[G2R0],X)
CLR()
SUM(RAM[G2R1],Z)

# G2R = G2R + E*2
CPY(,RAM[MY_W0])
SUM(RAM[G2R1],RAM[G2R1])
CLR()
SUM(RAM[G2R2],Z)

# G2L = G2L - G2R
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G2R0])
SUM(RAM[G2L0],RAM[G2L0])
CPY.INV(,RAM[G2R1])
SUM(RAM[G2L1],RAM[G2L1])
CPY.INV(,RAM[G2R2])
SUM(RAM[G2L2],RAM[G2L2])

# IF (G2L < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G1T = -G1T
CPY.INV(,RAM[G1T0])
SUM(RAM[G1T0],Y)
CPY.INV(,RAM[G1T1])
SUM(RAM[G1T1],Z)
CPY.INV(,RAM[G1T2])
SUM(RAM[G1T2],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# G1T = G1T + G2L (This is an approximation of G1T = SQRT(G1T^2 + G2L^2))
CPY(,RAM[G2L0])
SUM(RAM[G1T0],RAM[G1T0])
CPY(,RAM[G2L1])
SUM(RAM[G1T1],RAM[G1T1])
CPY(,RAM[G2L2])
SUM(RAM[G1T2],RAM[G1T2])
CLR()
SUM(,Z)

# Save G1T/2 out
CPY(NEWS,RAM[G1T1])
SAVE(IMG_NE0)

########################## SW ##########################
# Read ALL neigbors into ram. This will make calculations easier later

# ----------------- PLANE 0 -----------------
SET(NEWS)
BDR(SOUTH)
BDR(WEST)
CPY(NEWS,RAM[SE0])
BDR(EAST)
CPY(NEWS,RAM[NW0])
BDR(NORTH)
CPY(NEWS,RAM[SW0])
CPY(RAM[MY_E0],EAST)
CPY(RAM[MY_W0],WEST)
CPY(NEWS RAM[MY_N0],NORTH) # Shift south
CPY(RAM[MY_NE0],EAST)
CPY(RAM[MY_NW0],WEST)
CPY(NEWS,RAM[SW0]) # Restore
CPY(NEWS RAM[MY_S0],SOUTH) # Shift north
CPY(RAM[MY_SE0],EAST)
CPY(RAM[MY_SW0],WEST)
# ======================== G1 ===========================
# G1T = NE + NW
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_NW0]) # Add east and west together
CPY(RAM[G1T0],X)
CLR()
SUM(RAM[G1T1],Z)

# G1T = G1T + N*2
CPY(,RAM[MY_N0])
SUM(RAM[G1T1],RAM[G1T1])
CLR()
SUM(RAM[G1T2],Z)

# G1B = SE + SW
CPY(,RAM[MY_SE0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G1B0],X)
CLR()
SUM(RAM[G1B1],Z)

# G1B = G1B + S*2
CPY(,RAM[MY_S0])
SUM(RAM[G1B1],RAM[G1B1])
CLR()
SUM(RAM[G1B2],Z)

# G1T = G1T - G1B
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G1B0])
SUM(RAM[G1T0],RAM[G1T0])
CPY.INV(,RAM[G1B1])
SUM(RAM[G1T1],RAM[G1T1])
CPY.INV(,RAM[G1B2])
SUM(RAM[G1T2],RAM[G1T2])

# IF (G1T < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G1T = -G1T
CPY.INV(,RAM[G1T0])
SUM(RAM[G1T0],Y)
CPY.INV(,RAM[G1T1])
SUM(RAM[G1T1],Z)
CPY.INV(,RAM[G1T2])
SUM(RAM[G1T2],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# ======================== G2 ===========================
# G2L = NW + SW
CPY(,RAM[MY_NW0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G2L0],X)
CLR()
SUM(RAM[G2L1],Z)

# G2L = G2L + W*2
CPY(,RAM[MY_W0])
SUM(RAM[G2L1],RAM[G2L1])
CLR()
SUM(RAM[G2L2],Z)

# G2R = NE + SE
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_SE0]) # Add east and west together
CPY(RAM[G2R0],X)
CLR()
SUM(RAM[G2R1],Z)

# G2R = G2R + E*2
CPY(,RAM[MY_W0])
SUM(RAM[G2R1],RAM[G2R1])
CLR()
SUM(RAM[G2R2],Z)

# G2L = G2L - G2R
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G2R0])
SUM(RAM[G2L0],RAM[G2L0])
CPY.INV(,RAM[G2R1])
SUM(RAM[G2L1],RAM[G2L1])
CPY.INV(,RAM[G2R2])
SUM(RAM[G2L2],RAM[G2L2])

# IF (G2L < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G1T = -G1T
CPY.INV(,RAM[G1T0])
SUM(RAM[G1T0],Y)
CPY.INV(,RAM[G1T1])
SUM(RAM[G1T1],Z)
CPY.INV(,RAM[G1T2])
SUM(RAM[G1T2],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# G1T = G1T + G2L (This is an approximation of G1T = SQRT(G1T^2 + G2L^2))
CPY(,RAM[G2L0])
SUM(RAM[G1T0],RAM[G1T0])
CPY(,RAM[G2L1])
SUM(RAM[G1T1],RAM[G1T1])
CPY(,RAM[G2L2])
SUM(RAM[G1T2],RAM[G1T2])
CLR()
SUM(,Z)

# Save G1T/2 out
CPY(NEWS,RAM[G1T1])
SAVE(IMG_SW0)

########################## SE ##########################
# Read ALL neigbors into ram. This will make calculations easier later

# ----------------- PLANE 0 -----------------
SET(NEWS)
BDR(SOUTH)
BDR(EAST)
CPY(NEWS,RAM[SW0])
BDR(WEST)
CPY(NEWS,RAM[NE0])
BDR(NORTH)
CPY(NEWS,RAM[SE0])
CPY(RAM[MY_E0],EAST)
CPY(RAM[MY_W0],WEST)
CPY(NEWS RAM[MY_N0],NORTH) # Shift south
CPY(RAM[MY_NE0],EAST)
CPY(RAM[MY_NW0],WEST)
CPY(NEWS,RAM[SE0]) # Restore
CPY(NEWS RAM[MY_S0],SOUTH) # Shift north
CPY(RAM[MY_SE0],EAST)
CPY(RAM[MY_SW0],WEST)
# ======================== G1 ===========================
# G1T = NE + NW
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_NW0]) # Add east and west together
CPY(RAM[G1T0],X)
CLR()
SUM(RAM[G1T1],Z)

# G1T = G1T + N*2
CPY(,RAM[MY_N0])
SUM(RAM[G1T1],RAM[G1T1])
CLR()
SUM(RAM[G1T2],Z)

# G1B = SE + SW
CPY(,RAM[MY_SE0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G1B0],X)
CLR()
SUM(RAM[G1B1],Z)

# G1B = G1B + S*2
CPY(,RAM[MY_S0])
SUM(RAM[G1B1],RAM[G1B1])
CLR()
SUM(RAM[G1B2],Z)

# G1T = G1T - G1B
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G1B0])
SUM(RAM[G1T0],RAM[G1T0])
CPY.INV(,RAM[G1B1])
SUM(RAM[G1T1],RAM[G1T1])
CPY.INV(,RAM[G1B2])
SUM(RAM[G1T2],RAM[G1T2])

# IF (G1T < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G1T = -G1T
CPY.INV(,RAM[G1T0])
SUM(RAM[G1T0],Y)
CPY.INV(,RAM[G1T1])
SUM(RAM[G1T1],Z)
CPY.INV(,RAM[G1T2])
SUM(RAM[G1T2],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# ======================== G2 ===========================
# G2L = NW + SW
CPY(,RAM[MY_NW0]) 
SUM(X,RAM[MY_SW0]) # Add east and west together
CPY(RAM[G2L0],X)
CLR()
SUM(RAM[G2L1],Z)

# G2L = G2L + W*2
CPY(,RAM[MY_W0])
SUM(RAM[G2L1],RAM[G2L1])
CLR()
SUM(RAM[G2L2],Z)

# G2R = NE + SE
CPY(,RAM[MY_NE0]) 
SUM(X,RAM[MY_SE0]) # Add east and west together
CPY(RAM[G2R0],X)
CLR()
SUM(RAM[G2R1],Z)

# G2R = G2R + E*2
CPY(,RAM[MY_W0])
SUM(RAM[G2R1],RAM[G2R1])
CLR()
SUM(RAM[G2R2],Z)

# G2L = G2L - G2R
SET() # Set accumulator
SUM(,Y) # Add 1 to generate carry which we'll use for 2's complement
CPY.INV(,RAM[G2R0])
SUM(RAM[G2L0],RAM[G2L0])
CPY.INV(,RAM[G2R1])
SUM(RAM[G2L1],RAM[G2L1])
CPY.INV(,RAM[G2R2])
SUM(RAM[G2L2],RAM[G2L2])

# IF (G2L < 0)
CLR()
SUM.INV(FLAG,Z) # Positive sums generate a carry.

# G1T = -G1T
CPY.INV(,RAM[G1T0])
SUM(RAM[G1T0],Y)
CPY.INV(,RAM[G1T1])
SUM(RAM[G1T1],Z)
CPY.INV(,RAM[G1T2])
SUM(RAM[G1T2],Z)
CLR()
SUM(,Z) # Discard carry

# END IF
SET(FLAG)

# G1T = G1T + G2L (This is an approximation of G1T = SQRT(G1T^2 + G2L^2))
CPY(,RAM[G2L0])
SUM(RAM[G1T0],RAM[G1T0])
CPY(,RAM[G2L1])
SUM(RAM[G1T1],RAM[G1T1])
CPY(,RAM[G2L2])
SUM(RAM[G1T2],RAM[G1T2])
CLR()
SUM(,Z)

# Save G1T/2 out
CPY(NEWS,RAM[G1T1])
SAVE(IMG_SE0)
