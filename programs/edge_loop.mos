.CONST COLUMNS 2
.CONST ROWS 2
.CONST DEPTH 1
.CONST IMG 0x80
.CONST ROW_WIDTH 2+COLUMNS # include dummy elements
.CONST ROW_HEIGHT 16*COLUMNS
.CONST PLANE_HEIGHT ROW_HEIGHT*ROWS

.CONST NBR_N DEPTH*(0-ROW_WIDTH)
.CONST NBR_NE DEPTH*(1-ROW_WIDTH)
.CONST NBR_E DEPTH*(1)
.CONST NBR_SE DEPTH*(1+ROW_WIDTH)
.CONST NBR_S DEPTH*(ROW_WIDTH)
.CONST NBR_SW DEPTH*(ROW_WIDTH-1)
.CONST NBR_W DEPTH*(-1)
.CONST NBR_NW DEPTH*(-ROW_WIDTH-1)

# First row is a dummy row
LDREG($1, 0)
:Loop
	SET(RAM[$1+IMG])
	ADDREG($1, 1) # Branch delay
	BNE($1, NBR_S - 1, :Loop)

LDREG($5, 0) # Row source address
LDREG($2, DEPTH) # Depth counter
:LoadDepth
	ADDREG($2, -1)
	CPYREG($1, $2)
	ADDREG($1, NBR_S) # Starting point = IMG + NBR_S + depth
	LDREG($7, 0) # Row counter
	:LoadRow
		SET(RAM[$1+IMG]) # First column is a dummy column
		ADDREG($1, NBR_E)

		LDREG($6, 0) # Col counter
		CPYREG($4, $5) # Piece source address
		:LoadCol
			LOAD(RAM[$1+IMG], $4+0, COLUMNS)
			ADDREG($1, NBR_E)
			ADDREG($6, 1)
			ADDREG($4, 1)
			BNE($6, COLUMNS, :LoadCol)

		SET(RAM[$1+IMG]) # Last column is a dummy column
		ADDREG($1, NBR_E)
		ADDREG($7, 1)
		ADDREG($5, ROW_HEIGHT)
		BNE($7, ROWS, :LoadRow)
	BNE($2, 0, :LoadDepth)
	

# Last row is a dummy row
LDREG($2, 0)
:Loop
	SET(RAM[$1+IMG])
	ADDREG($2, 1)
	ADDREG($1, 1)
	BNE($2, NBR_S, :Loop)

LDREG($7, ROWS) # Row counter
LDREG($5, 0) # Row address in data cache
LDREG($1, IMG+NBR_S) # Offset to first row

:DoRow
	LDREG($6, COLUMNS) # Column counter
	CPYREG($4,$5) # Update column address in data cache
	ADDREG($1, NBR_E) # Skip west dummy
	:DoCol
		CPY(NEWS,RAM[$1+NBR_N])
		BDR(NORTH)
		CPY(NEWS,RAM[$1+NBR_S])
		BDR(SOUTH)
		CPY(NEWS,RAM[$1+NBR_E])
		BDR(EAST)
		CPY(NEWS,RAM[$1+NBR_W])
		BDR(WEST)
		CPY(NEWS,RAM[$1]) # Read image into output register
		CPY.INV(FLAG,RAM[$1]) # Clear flag for white pixels

		CPY(,NORTH) # Or all neighbors together
		OR(,EAST)
		OR(,WEST)
		OR.INV(NEWS, SOUTH) # If any of them are white, stay black

		SET(FLAG) # Restore flag so we can save out

		SAVE($4,COLUMNS) # Write out to the data cache
		
		ADDREG($4, 1) # Next address in data cache
		ADDREG($6, -1) # Decrement counter
		ADDREG($1, NBR_E) # Next element
		BNE($6, 0, :DoCol)
	ADDREG($1, NBR_E) # Skip east dummy
	ADDREG($7, -1)
	ADDREG($5, ROW_HEIGHT)
	BNE($7, 0, :DoRow)
